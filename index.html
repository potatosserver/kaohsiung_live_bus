
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta name="google-site-verification" content="ahdkishmook7wgZXJ6JVA43nNO5SSccNOlvmB575Od4" />
    <meta charset="UTF-8">
    <meta name="color-scheme" content="light dark" />
    <meta name="author" content="卓稟鈞(AndrewCho)">
    <meta name="description" content="一個專為高雄市公車設計的簡單、美觀且低流量站點搜尋器，提供快速查詢路線資訊功能，滿足即時需求，適合所有用戶使用。">
    <meta name="keywords" content="高雄市公車, 高雄公車, 高雄市公車即時資訊, 公車即時資訊, 公車式小黃, 公車小黃, 幹線, 幹線公車, 快線, 快線公車, 紅線公車, 橘線公車, 黃線公車, 綠線公車, Github, github.io" />
    <meta property="og:site_name" content="高雄即時公車動態" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>高雄市公車動態查詢器 : 一個簡單、美觀、低流量的高雄公車查詢器</title>

    <!-- Leaflet.js (for Map) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script type="application/ld+json">
    {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "高雄即時公車動態",
    "alternateName": ["高雄公車", "Kaohsiung Live Bus"],
    "url": "https://kaohsiung-live-bus.pages.dev/"
    }
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined&display=swap" rel="stylesheet">
    </script>
    <link rel="manifest" href="/manifest.json" />
    <link rel="icon" type="image/x-icon" href="/icons/icon.ico" />
    <style>
        :root {
            --go-color: #3b82f6; /* Blue for Go */
            --back-color: #ef4444; /* Red for Back */
        }

        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #f1f5f9;
            color: #1e293b;
            user-select: none; 
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
            transition: background-color 0.3s ease, color 0.3s ease;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100); /* 使用我們自訂的、穩定的 vh 變數 */
            overflow: hidden;
        }
        body.is-dragging-item {
            overflow: hidden; 
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-spinner {
            border: 4px solid #e2e8f0;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1.2s linear infinite;
        }
        .page {
            display: none;
            height: 100%;
            flex-direction: column;
        }
        .page.active {
            display: flex;
        }
        #estimateTimesSection {
            position: relative;
            overflow: hidden;
        }
        @keyframes slide-out-left {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(-100%); opacity: 0; }
        }
        @keyframes slide-in-from-right {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slide-out-right {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        @keyframes slide-in-from-left {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .slide-out-left { animation: slide-out-left 0.3s ease-out forwards; }
        .slide-in-from-right { animation: slide-in-from-right 0.3s ease-in forwards; }
        .slide-out-right { animation: slide-out-right 0.3s ease-out forwards; }
        .slide-in-from-left { animation: slide-in-from-left 0.3s ease-in forwards; }
        ::-webkit-scrollbar {
            width: 0px; 
            height: 0px; 
        }
        ::-webkit-scrollbar-track {
            background: transparent; 
        }
        ::-webkit-scrollbar-thumb {
            background: transparent; 
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: transparent; 
        }
        .material-icons-outlined {
            font-size: 24px;
        }
        /* 調整底部 Padding 以適應懸浮選單 */
        #routeSelectionPage .container, #mrtPage .container, #homePage .container {
            padding-bottom: 110px; /* 加大底部留白 */
        }
        @media (min-width: 768px) {
            #routeSelectionPage .container, #mrtPage .container, #homePage .container {
                padding-bottom: 120px;
            }
        }
        .bus-taxi-button {
            line-height: 1.2;
            white-space: normal;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.4rem 0.2rem;
        }
        .bus-taxi-button .bus-text,
        .bus-taxi-button .taxi-text {
            display: block;
        }
        @media (min-width: 768px) {
            .bus-taxi-button {
                padding: 0.75rem;
                flex-direction: row;
                white-space: nowrap;
            }
            .bus-taxi-button .bus-text,
            .bus-taxi-button .taxi-text {
                display: inline;
            }
        }
        #updateCountdown {
            white-space: nowrap;
            position: fixed;
            bottom: 100px; /* 調整位置，避開懸浮選單 */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            padding: 8px 16px;
            background-color: #e0f2fe; 
            color: #333;
            border: none;
            border-radius: 20px;
            font-size: 0.9em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            width: auto;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
        }
        #updateCountdown:hover {
            background-color: #bfdbfe;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        #updateCountdown .material-icons-outlined {
            font-size: 18px;
            vertical-align: middle;
        }
        @keyframes spin-180 {
            from { transform: rotate(0deg); }
            to { transform: rotate(180deg); }
        }
        .spin-update {
            animation: spin-180 0.5s ease forwards;
        }
        @media (max-width: 767px) {
            #filterKeyboard {
                gap: 4px !important;
                max-width: 384px;
                margin-left: auto;
                margin-right: auto;
            }
            #filterKeyboard > button {
                aspect-ratio: 1 / 1;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            #filterKeyboard .bus-taxi-button {
                padding: 4px;
                line-height: 1.1;
            }
        }

        /* --- NEW FLOATING CAPSULE NAVIGATION STYLE START --- */
        #mainNav {
            position: fixed;
            bottom: 20px; /* 距離底部 */
            left: 50%;    /* 水平置中 */
            transform: translateX(-50%);
            right: auto;
            width: calc(100% - 32px); /* 留邊距 */
            max-width: 500px; /* 平板/桌面限制寬度 */
            
            background-color: rgba(255, 255, 255, 0.85); /* 半透明玻璃 */
            backdrop-filter: blur(12px); /* 毛玻璃效果 */
            -webkit-backdrop-filter: blur(12px);
            
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 24px; /* 大圓角 */
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.15), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            
            z-index: 1000;
            display: flex;
            justify-content: space-around;
            padding: 8px 8px;
            transition: all 0.3s ease;
        }

        #mainNav button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            flex-basis: 0;
            padding: 4px 4px;
            font-size: 0.75rem;
            color: #64748b;
            background-color: transparent;
            border: none;
            cursor: pointer;
            border-radius: 16px; /* 按鈕圓角 */
            transition: color 0.2s, background-color 0.2s, transform 0.1s;
        }
        
        #mainNav button:active {
            transform: scale(0.95);
        }

        #mainNav button .material-icons-outlined {
            font-size: 26px;
            margin-bottom: 2px;
        }

        #mainNav button:hover {
            color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }

        #mainNav button.active-nav {
            color: #3b82f6;
            font-weight: 600;
            background-color: rgba(59, 130, 246, 0.1);
        }

        body.dark-mode #mainNav {
            background-color: rgba(30, 41, 59, 0.85); /* 深色玻璃 */
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }

        body.dark-mode #mainNav button { color: #94a3b8; }
        body.dark-mode #mainNav button:hover { color: #93c5fd; background-color: rgba(147, 197, 253, 0.1); }
        body.dark-mode #mainNav button.active-nav { color: #93c5fd; background-color: rgba(147, 197, 253, 0.15); }
        /* --- NEW FLOATING CAPSULE NAVIGATION STYLE END --- */

        #favoriteActionButton {
            position: fixed;
            padding: 8px 16px;
            background-color: #1d4ed8;
            color: white;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            font-size: 0.9em;
            cursor: pointer;
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.2s;
            transform: translateY(10px);
        }
        #favoriteActionButton.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        #favoriteActionButton:hover {
            background-color: #2563eb;
        }
        .toast-message {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 0.9em;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        .toast-message.show {
            opacity: 1;
        }
        .station-list-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            scroll-padding-top: 1rem;
        }
        #stationListGoContent, #stationListBackContent {
            position: relative;
            padding-left: 20px;
            padding-bottom: 40px; 
        }
        #stationListGoContent::before, #stationListBackContent::before {
            content: '';
            position: absolute;
            left: 21px;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #cbd5e1;
            z-index: 0;
        }
        body.dark-mode #stationListGoContent::before,
        body.dark-mode #stationListBackContent::before {
             background-color: #475569;
        }
        .station-item, .bus-card { /* Combine styles for new and old structure */
            position: relative;
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        .station-item:last-child {
            margin-bottom: 0;
        }
        .station-icon-container {
            position: absolute;
            left: -18px; 
            z-index: 1;
            background-color: #f1f5f9; /* Needs to match panel bg */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }
        body.dark-mode .station-icon-container {
            background-color: #0f172a; /* Needs to match dark panel bg */
        }
        .station-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .station-content {
            flex: 1;
            padding: 12px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-left: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        body.dark-mode .station-content {
            background-color: #1e293b;
        }
        .station-content .time-pill, .favorite-time-display .time-pill {
            flex-shrink: 0;
            min-width: 90px;
            text-align: center;
            padding: 6px 8px;
            border-radius: 9999px;
            font-weight: 700;
            font-size: 0.9em;
        }
        .time-pill.bg-slate-200 { background-color: #e2e8f0; color: #1e293b; } 
        .time-pill.bg-red-200 { background-color: #fee2e2; color: #b91c1c; } 
        .time-pill.bg-green-200 { background-color: #dcfce7; color: #166534; } 
        .time-pill.bg-blue-200 { background-color: #dbeafe; color: #1e40af; } 
        .favorite-time-display .time-pill.bg-yellow-200 { background-color: #fef9c3; color: #854d0e; } 
        .station-content .station-name {
            flex-grow: 1;
            font-weight: 500;
            color: #1e293b;
        }
        body.dark-mode .station-content .station-name {
            color: #e2e8f0;
        }
        .station-content .bus-id-display {
            flex-shrink: 0;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background-color: #dbeafe;
            color: #1e40af;
            font-size: 0.75em;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 9999px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        body.dark-mode .bus-id-display {
            background-color: #1e3a8a;
            color: #bfdbfe;
        }
        #favoriteListContainer .favorite-card-item {
            position: relative;
        }
        #favoriteListContainer .favorite-card-item.placeholder {
            opacity: 0.4;
            background: #e0f2fe;
            border: 2px dashed #3b82f6;
        }
        .dragging-ghost {
            position: absolute !important;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }
        .favorite-card-content {
            position: relative;
            display: flex;
            align-items: center;
            padding: 0.75rem; 
            background-color: #ffffff;
            width: 100%;
            box-sizing: border-box; 
        }
        .drag-handle {
            cursor: move;
            cursor: grab;
            padding: 8px;
            color: #94a3b8;
            touch-action: none;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        #favoriteGroupTabsContainer {
            display: flex;
            justify-content: flex-start;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        #favoriteGroupTabsContainer::-webkit-scrollbar {
            display: none;
        }
        .group-tab {
            flex-shrink: 0;
            padding: 8px 16px;
            margin: 0 4px;
            border-radius: 999px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            background-color: #e2e8f0;
            color: #475569;
            min-width: 5rem;
            text-align: center;
        }
        .group-tab[draggable="true"] {
            cursor: move;
            cursor: grab;
        }
        .group-tab[draggable="true"]:active {
            cursor: grabbing;
        }
        .group-tab.active {
            background-color: #3b82f6;
            color: white;
            font-weight: 600;
        }
        .group-tab.manage-btn {
            background-color: #f1f5f9;
            border: 1px solid #cbd5e1;
        }
        body.dark-mode .group-tab {
            background-color: #334155;
            color: #cbd5e1;
        }
        body.dark-mode .group-tab.active {
            background-color: #60a5fa;
            color: #1e293b;
        }
        body.dark-mode .group-tab.manage-btn {
            background-color: #1e293b;
            border: 1px solid #475569;
        }
        #manageGroupsModalBody .manage-group-item.group-placeholder {
            opacity: 0.4;
            background: #e0f2fe;
            border: 2px dashed #3b82f6;
        }
        body.dark-mode #manageGroupsModalBody .manage-group-item.group-placeholder {
            background: #0f172a;
            border-color: #60a5fa;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 24px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        body.dark-mode .modal-content {
            background-color: #1e293b;
        }
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3001; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .custom-modal.show {
            opacity: 1;
            visibility: visible;
        }
        .custom-modal-content {
            background-color: #ffffff;
            padding: 24px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transform: scale(0.95);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 180px;
        }
        .custom-modal.show .custom-modal-content {
            transform: scale(1);
        }
        body.dark-mode .custom-modal-content {
            background-color: #1e293b;
        }
        #customPromptMessage, #customConfirmMessage {
            flex-grow: 1;
        }
        .custom-modal-content input {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            margin-bottom: 20px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            background-color: #f8fafc;
            color: #1e293b;
        }
        body.dark-mode .custom-modal-content input {
            background-color: #334155;
            border-color: #475569;
            color: #e2e8f0;
        }
        .custom-modal-content input::placeholder {
            color: #94a3b8;
        }
        .custom-modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        .custom-modal-buttons button {
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .custom-modal-buttons .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .custom-modal-buttons .btn-primary:hover {
            background-color: #2563eb;
        }
        .btn-secondary {
            background-color: #e2e8f0;
            color: #1e293b;
        }
        body.dark-mode .btn-secondary {
            background-color: #334155;
            color: #e2e8f0;
        }
        .btn-secondary:hover {
            background-color: #cbd5e1;
            color: #1e293b;
        }
        body.dark-mode .btn-secondary:hover {
            background-color: #475569;
        }
        #homePage .weather-card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
            border: 1px solid #bfdbfe;
        }
        body.dark-mode #homePage .weather-card {
            background-color: #1e293b; 
            border-color: #334155; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        #homePage .weather-card h2 {
            color: #334155;
        }
        body.dark-mode #homePage .weather-card h2 {
            color: #e2e8f0; 
        }
        #homePage .weather-card p {
            color: #64748b;
        }
        body.dark-mode #homePage .weather-card p {
            color: #cbd5e1; 
        }
        #homePage .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        #homePage .weather-detail-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 0.5rem;
            margin-top: 1.5rem;
        }
        #homePage .detail-item {
            background-color: #f8fafc;
            padding: 0.75rem;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0;
            font-size: 0.875rem;
        }
        body.dark-mode #homePage .weather-detail-grid .detail-item {
            background-color: #0f172a; 
            border-color: #334155; 
        }
        #homePage .detail-label {
            font-weight: 600;
            color: #4a5568;
        }
        body.dark-mode #homePage .detail-label {
            color: #94a3b8; 
        }
        #homePage .detail-value {
            color: #2d3748;
            margin-top: 0.25rem;
        }
        body.dark-mode #homePage .detail-value {
            color: #e2e8f0; 
        }
        #homePage #temperature {
            color: #1e3a8a; 
        }
        body.dark-mode #homePage #temperature {
            color: #93c5fd; 
        }
        #homePage #weather-description {
            color: #4b5563; 
        }
        body.dark-mode #homePage #weather-description {
            color: #cbd5e1; 
        }
        body.dark-mode #homePage #error-message {
            color: #f87171; 
        }
        .weather-announcement-frame {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            max-width: 500px;
            width: 100%;
            margin: 20px auto;
            border: 1px solid #bfdbfe;
        }
        body.dark-mode .weather-announcement-frame {
            background-color: #1e293b;
            border-color: #334155;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .weather-announcement-frame .weather-card-inner,
        .weather-announcement-frame .message-announcement-card-inner {
            padding: 0;
            background-color: transparent;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }
        .weather-announcement-frame .message-announcement-card {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e2e8f0;
        }
        body.dark-mode .weather-announcement-frame .message-announcement-card {
            border-top-color: #334155;
        }
        #splashScreen {
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: #f0f2f5; 
            z-index: 9999; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            font-family: 'Montserrat', sans-serif; 
        }
        body.dark-mode #splashScreen {
            background-color: #0f172a; 
        }
        #animation-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .ibus-logo {
            font-family: 'Montserrat', sans-serif;
            font-size: 6rem;
            font-weight: 700;
            color: #0056b3; 
            animation: fadeInZoom 2s ease-in-out 0.2s forwards;
            opacity: 0;
            position: relative;
            z-index: 100;
        }
        body.dark-mode .ibus-logo {
            color: #93c5fd; 
        }
        @keyframes fadeInZoom {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
        #icons-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        .material-icons.spray-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            will-change: transform;
        }
        @keyframes marquee-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        .direction-button {
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        .direction-button .static-text {
            flex-shrink: 0;
            padding-right: 0.25rem;
        }
        .direction-button .marquee-container {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        .direction-button .marquee-text {
            display: inline-block;
            white-space: nowrap;
            will-change: transform;
        }
        .direction-button .marquee-text.is-overflowing {
            animation: marquee-scroll 10s linear infinite;
        }

        /* --- MAP.HTML MERGED STYLES START --- */
        #busTrackerPage .container { flex-grow: 1; display: flex; flex-direction: column; min-height: 0; padding-bottom: 70px; }
        #content-wrapper { flex-grow: 1; display: flex; flex-direction: column; min-height: 0; }
        #map {
            flex-grow: 1;
            width: 100%;
            background-color: #e5e7eb;
        }
        #busTrackerPage.map-hidden #map,
        #busTrackerPage.map-hidden #dragHandle {
            display: none;
        }
        #busTrackerPage.map-hidden #estimateTimesSection {
            height: 100% !important;
            flex-grow: 1;
        }
        #busTrackerPage #estimateTimesSection {
            flex-shrink: 0;
            height: 40vh; /* Initial height */
            background-color: #f1f5f9;
            display: flex;
            flex-direction: column;
        }
        body.dark-mode #busTrackerPage #estimateTimesSection {
            background-color: #0f172a;
        }
        #busTrackerPage .station-list-container {
            height: 100%;
            overflow-y: auto;
            padding: 1rem 1rem 1rem 0; /* Adjusted padding */
        }
        #dragHandle {
            flex-shrink: 0;
            height: 20px;
            width: 100%;
            cursor: ns-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f1f5f9;
            touch-action: none;
        }
        body.dark-mode #dragHandle {
            background-color: #0f172a;
        }
        #dragHandle::before {
            content: '';
            width: 80px;
            height: 5px;
            background: #cbd5e1;
            border-radius: 2.5px;
        }
        body.dark-mode #dragHandle::before {
            background: #475569;
        }
        .bus-icon {
            display: flex; justify-content: center; align-items: center; color: white; border-radius: 50%; width: 32px; height: 32px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4); border: 2px solid white;
        }
        .bus-icon.go-bus { background-color: var(--back-color); } /* 去程公車圖示改為紅色 */
        .bus-icon.back-bus { background-color: var(--go-color); } /* 返程公車圖示改為藍色 */
        .bus-icon .material-icons-outlined { font-size: 22px; }
        .station-number-icon {
            display: flex; justify-content: center; align-items: center; border-radius: 50%; color: white; font-weight: bold; font-size: 12px;
            line-height: 1; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        .station-number-icon.go-station { background-color: var(--go-color); }
        .station-number-icon.back-station { background-color: var(--back-color); }
        .leaflet-popup-content { margin: 12px; font-size: 14px; }
        .popup-header { font-weight: bold; font-size: 16px; margin-bottom: 8px; border-bottom: 1px solid #e2e8f0; padding-bottom: 5px; }
        .eta-container { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 5px; }
        .eta-tag { display: inline-flex; align-items: center; background-color: #27ae60; color: white; padding: 5px 10px; border-radius: 15px; font-size: 0.9em; }
        .eta-tag .bus-id { font-weight: bold; margin-right: 6px; background-color: rgba(0,0,0,0.15); padding: 2px 6px; border-radius: 10px; }
        .eta-approaching { background-color: #c0392b; }
        .eta-soon { background-color: #f39c12; }
        .no-data { color: #95a5a6; font-style: italic; }
        .station-list-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        /* --- MAP.HTML MERGED STYLES END --- */

        /* --- NEW MARQUEE & CYCLER STYLES START --- */
        @keyframes marquee-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        .marquee-container { overflow: hidden; white-space: nowrap; }
        .marquee-text.is-overflowing > * {
            display: inline-block;
            white-space: nowrap;
            animation-name: marquee-scroll;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }
        .marquee-inner { display: inline-block; padding-right: 2.5rem; }
        .info-cycler { position: relative; min-width: 5.5rem; height: 2rem; }
        .cycler-item {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            padding: 0 0.75rem; border-radius: 9999px;
            font-size: 0.875rem; font-weight: 700;
            opacity: 0; visibility: hidden;
            transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
        }
        .cycler-item.active { opacity: 1; visibility: visible; }
        @keyframes spin-once { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .is-refreshing { animation: spin-once 0.5s ease-out; }
        /* --- NEW MARQUEE & CYCLER STYLES END --- */

        body.dark-mode {
            background-color: #0f172a; 
            color: #e2e8f0; 
        }
        body.dark-mode .text-slate-800 { color: #e2e8f0; }
        body.dark-mode .text-slate-700 { color: #cbd5e1; }
        body.dark-mode .text-slate-600 { color: #94a3b8; }
        body.dark-mode .text-slate-500 { color: #64748b; }
        body.dark-mode .bg-white { background-color: #1e293b; } 
        body.dark-mode .border-slate-200 { border-color: #334155; } 
        body.dark-mode .border-slate-300 { border-color: #475569; } 
        body.dark-mode #searchBarContainer {
            background-color: #1e293b; 
            border-color: #475569; 
        }
        body.dark-mode #categoryDisplay { color: #93c5fd; } 
        body.dark-mode #searchBarContainer .w-px { background-color: #475569; }
        body.dark-mode #routeSearchInput { color: #e2e8f0; }
        body.dark-mode #routeSearchInput::placeholder { color: #94a3b8; }
        body.dark-mode #searchBarContainer svg { color: #94a3b8; }
        body.dark-mode .loading-spinner {
            border: 4px solid #334155; 
            border-top: 4px solid #60a5fa; 
        }
        body.dark-mode #noResultsMessage, body.dark-mode #noFavoritesMessage { color: #94a3b8; }
        body.dark-mode #filterKeyboardContainer {
            background-color: #1e293b; 
            border-top-color: #334155; 
        }
        body.dark-mode #filterKeyboard button {
             transition: background-color 0.2s ease;
        }
        body.dark-mode #filterKeyboard button[data-type="number"],
        body.dark-mode #filterKeyboard button[data-filter="幹線"],
        body.dark-mode #filterKeyboard button[data-filter="E"],
        body.dark-mode #filterKeyboard button[data-filter="其他"],
        body.dark-mode #filterKeyboard button[data-filter="reset"],
        body.dark-mode #filterKeyboard button[data-filter="backspace"],
        body.dark-mode #filterKeyboard .bus-taxi-button {
            background-color: #334155; 
            color: #e2e8f0;
        }
        body.dark-mode #filterKeyboard button[data-filter="紅"],
        body.dark-mode #filterKeyboard button[data-filter="橘"],
        body.dark-mode #filterKeyboard button[data-filter="黃"],
        body.dark-mode #filterKeyboard button[data-filter="綠"] {
            color: #0f172a; 
        }
        body.dark-mode #backButton {
            background-color: #334155;
            color: #e2e8f0;
        }
        body.dark-mode #backButton:hover { background-color: #475569; }
        body.dark-mode .direction-toggle-group { border-color: #60a5fa; }
        body.dark-mode .direction-button { background-color: transparent; color: #60a5fa; }
        body.dark-mode .direction-button.bg-blue-500 { background-color: #60a5fa; color: #1e293b; }
        .station-dot.go-station { background-color: var(--go-color); }
        .station-dot.back-station { background-color: var(--back-color); }
        body.dark-mode .station-dot { background-color: #60a5fa; }
        body.dark-mode .time-pill.bg-slate-200 { background-color: #334155; color: #cbd5e1; }
        body.dark-mode .time-pill.bg-red-200 { background-color: #991b1b; color: #fecaca; }
        body.dark-mode .time-pill.bg-green-200 { background-color: #166534; color: #dcfce7; }
        body.dark-mode .time-pill.bg-blue-200 { background-color: #1e40af; color: #dbeafe; }
        body.dark-mode .favorite-time-display .time-pill.bg-yellow-200 { background-color: #854d0e; color: #fef9c3; }
        body.dark-mode .favorite-card-item.placeholder { background: #0f172a; border-color: #60a5fa; }
        body.dark-mode .drag-handle { color: #64748b; }
        body.dark-mode .favorite-card-content { background-color: #1e293b; }
        body.dark-mode #updateCountdown {
            background-color: #e8def8;
            color: #1c1b1f;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        body.dark-mode #updateCountdown:hover {
            background-color: #d0bcff;
            color: #1c1b1f;
            box-shadow: 0 3px 6px rgba(0,0,0,0.4);
        }
        body.dark-mode .dark\:bg-slate-800 { background-color: #1e293b !important; }
        body.dark-mode .dark\:text-slate-200 { color: #e2e8f0; }
        body.dark-mode .dark\:text-slate-300 { color: #cbd5e1; }
        body.dark-mode .dark\:text-slate-400 { color: #94a3b8; }
        body.dark-mode .dark\:border-slate-700 { border-color: #334155; }
        body.dark-mode .dark\:hover\:bg-slate-700:hover { background-color: #334155; }
        body.dark-mode .dark\:bg-slate-700 { background-color: #334155; }
        body.dark-mode .dark\:border-slate-600 { border-color: #475569; }
        body.dark-mode .dark\:peer-focus\:ring-blue-800:focus { --tw-ring-color: rgba(30, 64, 175, 0.5); }
        body.dark-mode #languageSelect, body.dark-mode #defaultStartPageSelect, body.dark-mode #updateIntervalSelect {
            background-color: #334155; 
            color: #e2e8f0; 
            border-color: #475569; 
        }
        body.dark-mode #homePage .weather-card {
            background-color: #1e293b; 
            border-color: #334155; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        body.dark-mode #homePage .weather-card-inner h2 {
            color: #e2e8f0; 
        }
        body.dark-mode #homePage .weather-card-inner p {
            color: #cbd5e1; 
        }
        body.dark-mode #homePage .weather-detail-grid .detail-item {
            background-color: #0f172a; 
            border-color: #334155; 
        }
        body.dark-mode #homePage .weather-detail-grid .detail-label {
            color: #94a3b8; 
        }
        body.dark-mode #homePage .weather-detail-grid .detail-value {
            color: #e2e8f0; 
        }
        body.dark-mode #homePage #temperature {
            color: #93c5fd; 
        }
        body.dark-mode #homePage #weather-description {
            color: #cbd5e1; 
        }
        body.dark-mode #homePage #error-message {
            color: #f87171; 
        }
        body.dark-mode .message-announcement-card {
            background-color: #1e293b; 
            border-color: #334155; 
        }
        body.dark-mode .message-announcement-card h2 {
            color: #e2e8f0; 
        }
        body.dark-mode .message-announcement-card .text-slate-600 {
            color: #94a3b8; 
        }
        body.dark-mode .message-announcement-card .announcement-item {
            background-color: #0f172a; 
            border-color: #334155; 
        }
        body.dark-mode .message-announcement-card .announcement-item h3 {
            color: #e2e8f0; 
        }
        body.dark-mode .message-announcement-card .announcement-item p {
            color: #cbd5e1; 
        }
        .message-announcement-card .announcement-item p {
            white-space: pre-wrap; 
            overflow-wrap: break-word; 
            word-break: break-word; 
        }
        #homePage {
            overflow-y: auto;
        }
        #settingsPage .container {
            padding-bottom: 90px;
        }
        #settingsPage {
            overflow-y: auto;
        }
		#routeSelectionPage {
    		overflow-y: auto;
		}

/* --- LANDSCAPE MODE NAVIGATION & LAYOUT --- */
        @media (orientation: landscape) {
            /* Sidebar conversion with floating style */
            #mainNav {
                top: 50%; /* 垂直置中 */
                left: 20px;
                transform: translateY(-50%); /* 修正垂直置中 (覆蓋原本的 translateX) */
                bottom: auto;
                right: auto;
                
                width: 80px; /* 固定寬度 */
                height: auto; /* 高度自動 */
                max-height: 85vh; /* 避免太高 */
                
                flex-direction: column;
                justify-content: center;
                gap: 12px; /* 按鈕間距 */
                
                padding: 20px 0;
                border-radius: 24px;
                border-right: 1px solid rgba(255, 255, 255, 0.6); /* 恢復邊框邏輯但保持風格 */
                box-shadow: 5px 0 25px rgba(0,0,0,0.1);
            }
            
            body.dark-mode #mainNav {
                border-right: 1px solid rgba(255, 255, 255, 0.1);
            }

            #mainNav button {
                flex: 0 0 auto; /* 防止按鈕被過度拉伸 */
                width: 60px; /* 限制按鈕寬度 */
                margin: 0 auto; /* 水平置中 */
                padding: 10px 0;
                border-bottom: none;
            }

            /* Adjust main content containers */
            #routeSelectionPage .container, 
            #mrtPage .container, 
            #homePage .container,
            #settingsPage .container,
            #busTrackerPage .container,
            #favoriteStationsPage .container {
                padding-bottom: 20px !important;
                padding-left: 120px !important; /* 加大左側留白，避開懸浮選單 */
                max-width: 100% !important;
            }

            #mrtPage .container {
                padding-left: 100px !important;
                padding-right: 0 !important;
                padding-bottom: 0 !important;
            }

            #filterKeyboardContainer {
                left: 0px;
                width: 100%;
            }
            
            #updateCountdown {
                bottom: 20px; 
                left: calc(50% + 50px);
            }
            
            #toastContainer {
                 left: 50%;
            }

            /* ---------------------------------------------------------
               修改部分：地圖在右，列表在左
               --------------------------------------------------------- */
            
            /* 1. 設定容器為橫向 Flex */
            #busTrackerPage #content-wrapper {
                flex-direction: row !important;
                overflow: hidden;
            }

            /* 2. 地圖：放在順序 2 (右邊) */
            #busTrackerPage #map {
                flex-grow: 1;
                width: auto;
                height: 100% !important;
                order: 2; /* 關鍵：設定排序為第 2 個 */
            }

            /* 3. 路線列表：放在順序 1 (左邊) */
            #busTrackerPage #estimateTimesSection {
                width: 400px;
                max-width: 40vw;
                height: 100% !important;
                flex-shrink: 0;
                order: 1; /* 關鍵：設定排序為第 1 個 */
                
                /* 邊框調整：因為在左邊，所以分隔線要在右側 */
                border-left: none; 
                border-right: 1px solid #cbd5e1; 
                border-top: none; 
            }

            /* 深色模式下的分隔線顏色 */
            body.dark-mode #busTrackerPage #estimateTimesSection {
                border-right-color: #475569;
                border-left: none;
            }

            /* 隱藏原本上下的拖拉手柄 */
            #busTrackerPage #dragHandle {
                display: none !important;
            }

            /* 調整列表容器的內距 */
            #busTrackerPage .station-list-container {
                padding-top: 0 !important;
            }
        }
    </style>
</head>
<body class="antialiased">
    <div id="splashScreen">
        <div id="animation-container">
            <div class="ibus-logo">ibus</div>
            <div id="icons-container"></div>
        </div>
    </div>
    <div id="routeSelectionPage" class="page">
        <div class="container mx-auto p-4 md:p-6 max-w-4xl">
            <header class="text-center mb-6">
                <!-- MODIFICATION: h1 changed to h2 -->
                <h2 class="text-3xl md:text-4xl font-bold text-slate-800" data-i18n="routeSelectionTitle">高雄市公車路線查詢</h2>
                <p class="text-slate-500 mt-2" data-i18n="routeSelectionSubtitle">請使用下方鍵盤或直接輸入以查詢路線</p>
            </header>
            <div id="searchBarStickyWrapper" class="sticky top-0 z-10 bg-transparent py-2">
                <div id="searchBarContainer" class="flex items-center gap-2 bg-white border-2 border-slate-300 rounded-xl shadow-sm py-1 px-2 mx-auto max-w-sm md:max-w-4xl">
                    <div class="flex-shrink-0 pl-3 pr-2">
                        <span id="categoryDisplay" class="font-semibold text-blue-600" data-i18n="allRoutes">全部路線</span>
                    </div>
                    <div class="w-px bg-slate-300 self-stretch my-2"></div>
                    <div class="relative flex-grow">
                        <input type="text" id="routeSearchInput" placeholder="請由鍵盤輸入號碼" class="w-full py-2 px-3 text-lg bg-transparent border-none focus:outline-none focus:ring-0 text-left" readonly>
                        <svg class="w-6 h-6 text-slate-400 absolute top-1/2 right-3 -translate-y-1/2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                    </div>
                </div>
            </div>
            <div id="initialLoading" class="text-center py-20">
                <div class="loading-spinner mx-auto"></div>
                <p class="mt-4 text-slate-600" data-i18n="loadingRoutes">正在載入所有路線...</p>
            </div>
            <div id="routeListContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 max-w-sm md:max-w-4xl mx-auto">
                </div>
             <p id="noResultsMessage" class="text-center py-10 text-slate-500 text-lg hidden" data-i18n="noMatchingRoutes">找不到相符的路線。</p>
        </div>
        <div id="filterKeyboardContainer" class="fixed bottom-[1px] left-0 right-0 bg-slate-100 py-0 px-4 z-[999] shadow-lg">
            <div class="container mx-auto max-w-4xl">
                <div id="filterKeyboard" class="grid grid-cols-5 gap-x-0.5 gap-y-1 md:gap-2 py-2">
                    <button data-filter="紅" data-type="category" class="p-3 text-black font-bold bg-red-500 rounded-lg shadow-md">紅</button>
                    <button data-filter="幹線" data-type="category" class="p-3 bg-white rounded-lg shadow-md" data-i18n="mainLine">幹線</button>
                    <button data-filter="1" data-type="number" class="p-3 bg-white rounded-lg shadow-md">1</button>
                    <button data-filter="2" data-type="number" class="p-3 bg-white rounded-lg shadow-md">2</button>
                    <button data-filter="3" data-type="number" class="p-3 bg-white rounded-lg shadow-md">3</button>
                    <button data-filter="橘" data-type="category" class="p-3 text-black font-bold bg-orange-500 rounded-lg shadow-md">橘</button>
                    <button data-filter="E" data-type="category" class="p-3 bg-white rounded-lg shadow-md" data-i18n="expressLine">快線</button>
                    <button data-filter="4" data-type="number" class="p-3 bg-white rounded-lg shadow-md">4</button>
                    <button data-filter="5" data-type="number" class="p-3 bg-white rounded-lg shadow-md">5</button>
                    <button data-filter="6" data-type="number" class="p-3 bg-white rounded-lg shadow-md">6</button>
                    <button data-filter="黃" data-type="category" class="p-3 text-black font-bold bg-yellow-400 rounded-lg shadow-md">黃</button>
                    <button data-filter="小黃" data-type="category" class="bg-white rounded-lg shadow-md bus-taxi-button"><span class="bus-text" data-i18n="bus">公車</span><span class="taxi-text" data-i18n="taxi">小黃</span></button>
                    <button data-filter="7" data-type="number" class="p-3 bg-white rounded-lg shadow-md">7</button>
                    <button data-filter="8" data-type="number" class="p-3 bg-white rounded-lg shadow-md">8</button>
                    <button data-filter="9" data-type="number" class="p-3 bg-white rounded-lg shadow-md">9</button>
                    <button data-filter="綠" data-type="category" class="p-3 text-black font-bold bg-green-500 rounded-lg shadow-md">綠</button>
                    <button data-filter="其他" data-type="category" class="p-3 bg-white rounded-lg shadow-md" data-i18n="otherRoutes">其他</button>
                    <button data-filter="reset" data-type="action" class="p-3 bg-white rounded-lg shadow-md" data-i18n="reset">重設</button>
                    <button data-filter="0" data-type="number" class="p-3 bg-white rounded-lg shadow-md">0</button>
                    <button data-filter="backspace" data-type="action" class="p-3 bg-white text-slate-800 rounded-lg shadow-md flex justify-center items-center">
                        <span class="material-icons-outlined">backspace</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    <div id="busTrackerPage" class="page">
        <div class="container mx-auto max-w-4xl">
             <header class="p-4 flex-shrink-0">
                <div class="flex items-center justify-center mb-2">
                    <!-- MODIFICATION: h1 changed to h2 -->
                    <h2 id="routeTitle" class="text-xl md:text-2xl font-bold text-slate-800 text-center flex-grow"></h2>
                </div>
                <p id="routeDescription" class="text-sm text-slate-500 text-center mb-4"></p>
    <div class="direction-toggle-group flex justify-center mt-4 mb-0 rounded-lg border-2 border-blue-500 overflow-hidden text-sm">                    <button id="goDirectionButton" class="direction-button flex-1 p-2 font-semibold" data-direction="1">
                        <span class="static-text" data-i18n="goDirection">去程</span>
                        <span class="marquee-container">
                            <span class="marquee-text"></span>
                        </span>
                    </button>
                    <button id="backDirectionButton" class="direction-button flex-1 p-2 font-semibold" data-direction="2">
                        <span class="static-text" data-i18n="backDirection">返程</span>
                        <span class="marquee-container">
                            <span class="marquee-text"></span>
                        </span>
                    </button>
                </div>
            </header>
            
            <div id="content-wrapper">
                <div id="map"></div>
                <div id="estimateTimesSection">
                    <div id="dragHandle"></div>
                    <div class="relative flex-grow min-h-0">
                         <div id="trackerLoading" class="absolute inset-0 bg-white/70 dark:bg-slate-800/70 z-20 flex items-center justify-center flex-col hidden">
                            <div class="loading-spinner mx-auto"></div>
                            <p class="mt-4 text-slate-600 text-sm" data-i18n="loadingBusData">正在載入路線動態...</p>
                        </div>
                        <div id="stationListGo" class="station-list-wrapper">
                            <div class="station-list-container">
                                <div id="stationListGoContent"></div>
                            </div>
                        </div>
                        <div id="stationListBack" class="station-list-wrapper hidden">
                             <div class="station-list-container">
                                <div id="stationListBackContent"></div>
                            </div>
                        </div>
                         <p id="offlineNotice" class="text-center py-10 text-slate-500 text-lg hidden" data-i18n="networkErrorOfflineView"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="favoriteStationsPage" class="page">
        <div class="container mx-auto p-4 md:p-6 max-w-4xl h-screen flex flex-col">
            <div class="flex-shrink-0">
                <header class="text-center mb-6">
                    <!-- MODIFICATION: h1 changed to h2 -->
                    <h2 class="text-3xl md:text-4xl font-bold text-slate-800" data-i18n="favoritesTitle">常用站牌</h2>
                    <p class="text-slate-500 mt-2" data-i18n="favoritesSubtitle">點擊可查看路線詳情，長按可移除，拖動以排序。</p>
                </header>
                <div id="favoriteGroupTabsContainer" class="mb-6 pb-2">
                </div>
            </div>
            <div class="flex-grow overflow-y-auto relative">
                <div id="favoriteListContainer" class="space-y-3">
                </div>
                <div id="noFavoritesMessage" class="text-center py-20 text-slate-500 hidden">
                    <p data-i18n="noFavoritesYet">還沒有常用站牌喔！</p>
                    <p class="mt-2 text-sm" data-i18n="addFavoritesHint">在路線動態頁面，長按或右鍵點擊站牌即可將其加入最愛。</p>
                </div>
            </div>
        </div>
    </div>
    <div id="mrtPage" class="page">
        <div class="container mx-auto p-4 md:p-6 max-w-4xl h-screen flex flex-col">
            <div class="flex-grow relative -mx-4 -mb-4 md:-mx-6 md:-mb-6">
                <iframe src="about:blank" id="mrtIframe" style="width: 100%; height: 100%; border: none;"></iframe>
            </div>
        </div>
    </div>
    <div id="homePage" class="page">
        <div class="container mx-auto p-4 md:p-6 max-w-4xl">
            <header class="text-center mb-4">
                <!-- MODIFICATION: This is the main h1 -->
                <h1 class="text-2xl md:text-3xl font-bold text-slate-800" data-i18n="appTitle">高雄公車 App</h1>
                <p class="text-slate-500 mt-1" data-i18n="appSubtitle">您的即時公車夥伴</p>
            </header>
            <div class="weather-announcement-frame">
                <div class="weather-card-inner">
                    <h2 class="text-2xl font-bold text-gray-800 mb-2" data-i18n="weatherTitle">高雄天氣</h2>
                    <p class="text-lg text-gray-600 mb-6" id="current-date"></p>
                    <div id="weatherLoading" class="loading-spinner"></div>
                    <div id="weatherErrorMessage" class="text-red-500 text-center hidden" data-i18n="weatherLoadError">無法載入天氣資料，請稍後再試。</div>
                    <div id="weatherInfo" class="hidden">
                        <div class="flex items-center justify-center mb-4">
                            <span id="weather-icon" class="text-5xl mr-3"></span>
                            <p class="text-4xl font-extrabold text-blue-600" id="temperature"></p>
                            <span class="text-2xl text-blue-600 ml-1">°C</span>
                        </div>
                        <p class="text-xl text-gray-700 font-semibold mb-4" id="weather-description"></p>
                        <div class="weather-detail-grid">
                            <div class="detail-item">
                                <div class="detail-label" data-i18n="apparentTemperature">體感溫度</div>
                                <div class="detail-value" id="apparent-temperature"></div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label" data-i18n="relativeHumidity">相對濕度</div>
                                <div class="detail-value" id="relative-humidity"></div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label" data-i18n="windSpeed">風速</div>
                                <div class="detail-value" id="wind-speed"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="message-announcement-card message-announcement-card-inner bg-blue-50 rounded-lg shadow-md p-4 md:p-6 border border-blue-200">
                    <h2 class="text-xl md:text-2xl font-bold text-slate-800 mb-4" data-i18n="announcementTitle">訊息公告</h2>
                    <div id="announcementContent">
                        <div id="announcementLoading" class="text-center py-4">
                            <div class="loading-spinner mx-auto"></div>
                            <p class="mt-2 text-slate-600" data-i18n="loadingAnnouncements">正在載入訊息公告...</p>
                        </div>
                        <p id="noAnnouncementsMessage" class="text-center py-4 text-slate-500 hidden" data-i18n="noAnnouncements">目前沒有任何訊息通知喔</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="settingsPage" class="page">
        <div class="container mx-auto p-4 md:p-6 max-w-4xl">
            <header class="text-center mb-6">
                <!-- MODIFICATION: h1 changed to h2 -->
                <h2 class="text-3xl md:text-4xl font-bold text-slate-800" data-i18n="settingsTitle">設定</h2>
                <p class="text-slate-500 mt-2" data-i18n="settingsSubtitle">調整應用程式設定。</p>
            </header>
            <div class="space-y-6">
                <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-4 border-b border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700" data-i18n="appearance">外觀</h2>
                    </div>
                    <div class="p-4 space-y-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="material-icons-outlined text-slate-500 mr-3">dark_mode</span>
                                <span class="text-slate-600" data-i18n="darkMode">深色模式</span>
                            </div>
                            <label for="darkModeToggle" class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="darkModeToggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-slate-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-slate-600 peer-checked:bg-blue-600"></div>
                            </label>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="material-icons-outlined text-slate-500 mr-3">animation</span>
                                <span class="text-slate-600" data-i18n="splashScreen">啟動動畫</span>
                            </div>
                            <label for="splashScreenToggle" class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="splashScreenToggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-slate-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-slate-600 peer-checked:bg-blue-600"></div>
                            </label>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="material-icons-outlined text-slate-500 mr-3">map</span>
                                <span class="text-slate-600" data-i18n="showMap">顯示地圖</span>
                            </div>
                            <label for="mapDisplayToggle" class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="mapDisplayToggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-slate-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-slate-600 peer-checked:bg-blue-600"></div>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-4 border-b border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700" data-i18n="defaultStartPageTitle">預設起始頁面</h2>
                    </div>
                    <div class="p-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="material-icons-outlined text-slate-500 mr-3">web</span>
                                <span class="text-slate-600" data-i18n="defaultStartPageSubtitle">選擇啟動時的頁面</span>
                            </div>
                            <select id="defaultStartPageSelect" class="bg-slate-100 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-slate-700 dark:border-slate-600 dark:placeholder-slate-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
                                <option value="home" data-i18n="navHome">首頁</option>
                                <option value="dynamic" data-i18n="navDynamic">動態</option>
                                <option value="favoriteStations" data-i18n="navFavorites">最愛</option>
                                <option value="mrt" data-i18n="navMrt">捷運</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-4 border-b border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700" data-i18n="updateIntervalTitle">自動更新頻率</h2>
                    </div>
                    <div class="p-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="material-icons-outlined text-slate-500 mr-3">timer</span>
                                <span class="text-slate-600" data-i18n="updateIntervalSubtitle">設定動態更新秒數</span>
                            </div>
                            <select id="updateIntervalSelect" class="bg-slate-100 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-slate-700 dark:border-slate-600 dark:placeholder-slate-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
                                <option value="10">10 秒</option>
                                <option value="20">20 秒</option>
                                <option value="30">30 秒</option>
                                <option value="40">40 秒</option>
                                <option value="60">60 秒</option>
                            </select>
                        </div>
                        <p class="text-xs text-slate-500 dark:text-slate-400 mt-2" data-i18n="updateIntervalWarning">
                            高於30秒可能導致資訊過慢，請自行斟酌。
                        </p>
                    </div>
                </div>
                <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-4 border-b border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700" data-i18n="languageSettings">語言設定</h2>
                    </div>
                    <div class="p-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="material-icons-outlined text-slate-500 mr-3">language</span>
                                <span class="text-slate-600" data-i18n="selectLanguage">選擇語言</span>
                            </div>
                            <select id="languageSelect" class="bg-slate-100 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-slate-700 dark:border-slate-600 dark:placeholder-slate-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
                                <option value="zh">繁體中文</option>
                                <option value="en">English</option>
                            </select>
                        </div>
                    </div>
                </div>
                                <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-4 border-b border-slate-200">
                        <h2 class="text-lg font-semibold text-slate-700" data-i18n="about">關於</h2>
                    </div>
                    <div class="p-4 space-y-2">
                        <a href="https://github.com/potatosserver/kaohsiung_live_bus" target="_blank" rel="noopener noreferrer" class="flex items-center justify-between text-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg p-2 transition-colors -m-2">
                            <div class="flex items-center">
                                <svg class="w-6 h-6 mr-3 fill-current" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 4.418 2.865 8.168 6.839 9.492.5.092.682-.217.682-.482 0-.237-.009-.868-.014-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.031-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.378.203 2.398.1 2.651.64.7 1.03 1.595 1.03 2.688 0 3.848-2.338 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.001 10.001 0 0022 12c0-5.523-4.477-10-10-10z" clip-rule="evenodd" /></svg>
                                <span data-i18n="githubSource">GitHub 原始碼</span>
                            </div>
                            <span class="material-icons-outlined text-slate-400">open_in_new</span>
                        </a>
                        <div class="flex items-center text-slate-600 dark:text-slate-300 p-2 -m-2">
                            <span class="material-icons-outlined text-slate-500 mr-3">badge</span>
                            <span data-i18n="authorName">作者：卓稟鈞 (Andrew)</span>
                        </div>
                        <a href="https://potatosserver.github.io/" target="_blank" rel="noopener noreferrer" class="flex items-center justify-between text-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg p-2 transition-colors -m-2">
                            <div class="flex items-center">
                                <span class="material-icons-outlined text-slate-500 mr-3">public</span>
                                <span data-i18n="authorWebsite">作者網站</span>
                            </div>
                            <span class="material-icons-outlined text-slate-400">open_in_new</span>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <button id="updateCountdown" style="display:none;">
        <span class="material-icons-outlined">autorenew</span>
        <span id="updateCountdownText" data-i18n="updateCountdown">20秒後更新</span>
    </button>
    <button id="favoriteActionButton" class="hidden">
        <span class="material-icons-outlined" id="favoriteActionIcon"></span>
        <span id="favoriteActionText"></span>
    </button>
    <div id="toastContainer" class="fixed bottom-20 left-1/2 -translate-x-1/2 z-[2000] flex flex-col items-center space-y-2"></div>
    <div id="mainNav">
        <button id="navHome" data-page="home">
            <span class="material-icons-outlined">home</span>
            <span data-i18n="navHome">首頁</span>
        </button>
        <button id="navDynamic" data-page="dynamic">
            <span class="material-icons-outlined">directions_bus</span>
            <span data-i18n="navDynamic">動態</span>
        </button>
        <button id="navFavorites" data-page="favoriteStations">
            <span class="material-icons-outlined">favorite</span>
            <span data-i18n="navFavorites">最愛</span>
         </button>
        <button id="navMrt" data-page="mrt">
            <span class="material-icons-outlined">tram</span>
            <span data-i18n="navMrt">捷運</span>
        </button>
        <button id="navSettings" data-page="settings">
            <span class="material-icons-outlined">settings</span>
            <span data-i18n="navSettings">設定</span>
        </button>
    </div>
    <div id="selectGroupModal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="text-lg font-bold mb-4 text-slate-800" data-i18n="selectGroupTitle">選擇分組</h3>
            <div id="selectGroupModalBody" class="space-y-2">
            </div>
            <button id="closeSelectGroupModal" class="mt-4 w-full text-center py-2 rounded-lg btn-secondary" data-i18n="cancel">取消</button>
        </div>
    </div>
    <div id="manageGroupsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-slate-800" data-i18n="manageGroupsTitle">管理分組</h3>
                <button id="closeManageGroupsModal" class="p-1 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700">
                    <span class="material-icons-outlined">close</span>
                </button>
            </div>
            <div id="manageGroupsModalBody" class="space-y-2 max-h-60 overflow-y-auto mb-4">
            </div>
            <button id="addNewGroupBtn" class="w-full text-center py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors" data-i18n="addNewGroup">新增分組</button>
        </div>
    </div>
    <div id="customPromptModal" class="custom-modal">
        <div class="custom-modal-content">
            <h3 id="customPromptTitle" class="text-lg font-bold mb-2 text-slate-800"></h3>
            <p id="customPromptMessage" class="text-slate-700 mb-4"></p>
            <input type="text" id="customPromptInput" class="custom-modal-input" />
            <div class="custom-modal-buttons">
                <button id="customPromptCancelBtn" class="btn-secondary" data-i18n="cancel">取消</button>
                <button id="customPromptConfirmBtn" class="btn-primary" data-i18n="confirm">確認</button>
            </div>
        </div>
    </div>
    <div id="customConfirmModal" class="custom-modal">
        <div class="custom-modal-content">
            <h3 id="customConfirmTitle" class="text-lg font-bold mb-2 text-slate-800"></h3>
            <p id="customConfirmMessage" class="text-slate-700 mb-4"></p>
            <div class="custom-modal-buttons">
                <button id="customConfirmCancelBtn" class="btn-secondary" data-i18n="cancel">取消</button>
                <button id="customConfirmConfirmBtn" class="btn-primary" data-i18n="confirm">確認</button>
            </div>
        </div>
    </div>
    <script>
        function setViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        setViewportHeight();
        window.addEventListener('resize', setViewportHeight);
        window.addEventListener('orientationchange', setViewportHeight);
        document.addEventListener('DOMContentLoaded', async () => {
            const splashScreen = document.getElementById('splashScreen');
            const body = document.body;
            if (localStorage.getItem('darkMode') === 'true') {
                body.classList.add('dark-mode');
            }
            const urlParams = new URLSearchParams(window.location.search);
            const isDeepLink = urlParams.has('route'); 
            const isUserEnabled = localStorage.getItem('splashScreenEnabled') !== 'false';
            const showSplashScreen = isUserEnabled && !isDeepLink;

            const startApp = () => {
                const splashScreen = document.getElementById('splashScreen');
                if(splashScreen) {
                    splashScreen.style.transition = 'opacity 0.5s ease-out';
                    splashScreen.style.opacity = '0';
                    splashScreen.addEventListener('transitionend', () => {
                        if (splashScreen) splashScreen.remove(); 
                    }, { once: true });
                }
                initializeApp(); 
            };
            if (showSplashScreen) {
                function startIconPhysics() {
                    const container = document.getElementById('icons-container');
                    if (!container) return;
                    const iconNames = [
                        'directions_bus', 'commute', 'map', 'pin_drop', 'explore', 'rocket_launch',
                        'favorite', 'star', 'settings', 'place', 'local_shipping', 'emoji_transportation',
                        'route', 'navigation', 'trip_origin'
                    ];
                    const numIcons = 200;
                    let icons = [];
                    const gravity = 0.2;
                    const initialUpwardVelocity = -13;
                    for (let i = 0; i < numIcons; i++) {
                        const element = document.createElement('span');
                        element.classList.add('material-icons', 'spray-icon');
                        element.textContent = iconNames[Math.floor(Math.random() * iconNames.length)];
                        const size = Math.random() * 22 + 18;
                        element.style.fontSize = size + 'px';
                        element.style.color = `hsl(${Math.random() * 360}, 70%, 65%)`;
                        container.appendChild(element);
                        icons.push({
                            element: element,
                            x: 0,
                            y: 0,
                            vx: (Math.random() - 0.5) * 18,
                            vy: initialUpwardVelocity * (Math.random() * 0.5 + 0.8),
                        });
                    }
                    function update() {
                        const killMargin = 100;
                        const killZone = {
                            top: -window.innerHeight / 2 - killMargin,
                            right: window.innerWidth / 2 + killMargin,
                            bottom: window.innerHeight / 2 + killMargin,
                            left: -window.innerWidth / 2 - killMargin
                        };
                        for (let i = icons.length - 1; i >= 0; i--) {
                            let icon = icons[i];
                            icon.vy += gravity;
                            icon.x += icon.vx;
                            icon.y += icon.vy;
                            if (icon.x < killZone.left || icon.x > killZone.right || icon.y < killZone.top || icon.y > killZone.bottom) {
                                if(icon.element) icon.element.remove();
                                icons.splice(i, 1);
                            } else {
                                icon.element.style.transform = `translate(${icon.x}px, ${icon.y}px)`;
                            }
                        }
                        if (icons.length > 0) {
                            requestAnimationFrame(update);
                        }
                    }
                    update();
                }
                setTimeout(startIconPhysics, 600);
                setTimeout(startApp, 2800); 
            } else {
                if(splashScreen) {
                    splashScreen.remove();
                }
                initializeApp();
            }
            async function initializeApp() {
                try { 
                    const API_URL = 'https://ibus.tbkc.gov.tw/ibus/graphql';
                    const HEADERS = {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    };
                    const body = document.body;
                    const routeSelectionPage = document.getElementById('routeSelectionPage');
                    const busTrackerPage = document.getElementById('busTrackerPage');
                    const favoriteStationsPage = document.getElementById('favoriteStationsPage');
                    const mrtPage = document.getElementById('mrtPage');
                    const homePage = document.getElementById('homePage');
                    const settingsPage = document.getElementById('settingsPage');
                    const mrtIframe = document.getElementById('mrtIframe');
                    const routeSearchInput = document.getElementById('routeSearchInput');
                    const categoryDisplay = document.getElementById('categoryDisplay');
                    const routeListContainer = document.getElementById('routeListContainer');
                    const initialLoading = document.getElementById('initialLoading');
                    const noResultsMessage = document.getElementById('noResultsMessage');
                    const filterKeyboard = document.getElementById('filterKeyboard');
                    const filterKeyboardContainer = document.getElementById('filterKeyboardContainer');
                    const trackerLoading = document.getElementById('trackerLoading');
                    const routeTitle = document.getElementById('routeTitle');
                    const routeDescription = document.getElementById('routeDescription');
                    const stationListGo = document.getElementById('stationListGo');
                    const stationListBack = document.getElementById('stationListBack');
                    const stationListGoContent = document.getElementById('stationListGoContent');
                    const stationListBackContent = document.getElementById('stationListBackContent');
                    const goDirectionButton = document.getElementById('goDirectionButton');
                    const backDirectionButton = document.getElementById('backDirectionButton');
                    const updateCountdownButton = document.getElementById('updateCountdown');
                    const mainNav = document.getElementById('mainNav');
                    const favoriteListContainer = document.getElementById('favoriteListContainer');
                    const noFavoritesMessage = document.getElementById('noFavoritesMessage');
                    const favoriteGroupTabsContainer = document.getElementById('favoriteGroupTabsContainer');
                    const favoriteActionButton = document.getElementById('favoriteActionButton');
                    const favoriteActionIcon = document.getElementById('favoriteActionIcon');
                    const favoriteActionText = document.getElementById('favoriteActionText');
                    const toastContainer = document.getElementById('toastContainer');
                    const selectGroupModal = document.getElementById('selectGroupModal');
                    const selectGroupModalBody = document.getElementById('selectGroupModalBody');
                    const closeSelectGroupModal = document.getElementById('closeSelectGroupModal');
                    const manageGroupsModal = document.getElementById('manageGroupsModal');
                    const manageGroupsModalBody = document.getElementById('manageGroupsModalBody');
                    const closeManageGroupsModal = document.getElementById('closeManageGroupsModal');
                    const addNewGroupBtn = document.getElementById('addNewGroupBtn');
                    const customPromptModal = document.getElementById('customPromptModal');
                    const customPromptTitle = document.getElementById('customPromptTitle');
                    const customPromptMessage = document.getElementById('customPromptMessage');
                    const customPromptInput = document.getElementById('customPromptInput');
                    const customPromptConfirmBtn = document.getElementById('customPromptConfirmBtn');
                    const customPromptCancelBtn = document.getElementById('customPromptCancelBtn');
                    const customConfirmModal = document.getElementById('customConfirmModal');
                    const customConfirmTitle = document.getElementById('customConfirmTitle');
                    const customConfirmMessage = document.getElementById('customConfirmMessage');
                    const customConfirmConfirmBtn = document.getElementById('customConfirmConfirmBtn');
                    const customConfirmCancelBtn = document.getElementById('customConfirmCancelBtn');
                    const darkModeToggle = document.getElementById('darkModeToggle');
                    const splashScreenToggle = document.getElementById('splashScreenToggle');
                    const mapDisplayToggle = document.getElementById('mapDisplayToggle');
                    const languageSelect = document.getElementById('languageSelect');
                    const defaultStartPageSelect = document.getElementById('defaultStartPageSelect');
                    const updateIntervalSelect = document.getElementById('updateIntervalSelect');
                    const weatherLoadingElement = document.getElementById('weatherLoading');
                    const weatherErrorMessageElement = document.getElementById('weatherErrorMessage');
                    const weatherInfoElement = document.getElementById('weatherInfo');
                    const temperatureElement = document.getElementById('temperature');
                    const weatherDescriptionElement = document.getElementById('weather-description');
                    const weatherIconElement = document.getElementById('weather-icon');
                    const apparentTemperatureElement = document.getElementById('apparent-temperature');
                    const relativeHumidityElement = document.getElementById('relative-humidity');
                    const windSpeedElement = document.getElementById('wind-speed');
                    const currentDateElement = document.getElementById('current-date');
                    const announcementContent = document.getElementById('announcementContent');
                    const announcementLoading = document.getElementById('announcementLoading');
                    const noAnnouncementsMessage = document.getElementById('noAnnouncementsMessage');
                    
                    let allRoutes = [];
                    let currentRouteData = null;
                    let currentDirection = 1; 
                    let currentRouteId = null;
                    let currentRouteName = null;
                    let countdownInterval = null;
                    let currentLang = "zh";
                    let defaultStartPage = 'home';
                    let updateInterval = 20; 
                    let routeDataLang = null;
                    let activePage = 'homePage'; 
                    let selectedCategoryPrefix = '';
                    let favoriteData = { groups: [], favorites: [], groupOrder: { all: [] } };
                    let activeGroupId = 'all'; 
                    let longPressTimer;
                    let currentStationContext = null;
                    let favoriteButtonHideTimeout;
                    let draggedItem = null;
                    let draggedGroupTab = null;
                    let isAnimatingDirection = false;
                    let lastPage = null;
                    let weatherDataLoaded = false;
                    let announcementsDataLoaded = false;
                    let mrtIframeLoaded = false;
                    let resolveCustomPrompt;
                    let resolveCustomConfirm;
                    const favoritePage = document.getElementById('favoriteStationsPage');
                    let favTouchStartX = 0, favTouchStartY = 0;
                    let favTouchEndX = 0, favTouchEndY = 0;
                    let isDraggingTouch = false;
                    let placeholder = null; 
                    let ghost = null; 
                    let startYTouch = 0;
                    let startTop = 0;
                    let favoriteUpdateInterval = null;

                    let draggedGroupItem = null;
                    let groupPlaceholder = null;
                    let groupGhost = null;
                    let startYGroupTouch = 0;
                    let startTopGroup = 0;

                    let map = null;
                    let goLayerGroup, backLayerGroup, goBusLayerGroup, backBusLayerGroup;
                    let isFirstMapLoad = true;
                    let busMarkers = {};

                    const MARQUEE_SPEED_PPS = 50;
                    let infoCyclerInterval = null;
                    
                    const translations = {
                        zh: {
                            appTitle: '高雄公車 App',
                            appSubtitle: '您的即時公車夥伴',
                            routeSelectionTitle: '高雄市公車路線查詢',
                            routeSelectionSubtitle: '請使用下方鍵盤或直接輸入以查詢路線',
                            allRoutes: '全部路線',
                            routeSearchPlaceholder: '請由鍵盤輸入號碼',
                            loadingRoutes: '正在載入所有路線...',
                            noMatchingRoutes: '找不到相符的路線。',
                            mainLine: '幹線',
                            expressLine: '快線',
                            bus: '公車',
                            taxi: '小黃',
                            otherRoutes: '其他',
                            reset: '重設',
                            errorTitle: '錯誤!',
                            goDirection: '去程往',
                            backDirection: '返程往',
                            loadingBusData: '正在載入路線動態...',
                            noBusDataForDirection: '此方向目前沒有班次資訊。',
                            lastBusDeparted: '末班駛離',
                            approaching: '進站中',
                            arrivingSoon: '即將到站',
                            minutes: '分',
                            unknownStation: '未知站點',
                            removeFavorite: '移除最愛',
                            addFavorite: '加入最愛',
                            favoritesTitle: '常用站牌',
                            mapStopOrder: '站序：',
                            mapRealTimeStatus: '即時動態：',
                            mapBusPlate: '車牌：',
                            networkErrorOfflineView: '網路連線失敗，無法顯示即時動態。',
                            offlineStatus: '離線',
                            favoritesSubtitle: '點擊可查看路線詳情，長按可移除，拖動以排序。',
                            noFavoritesYet: '還沒有常用站牌喔！',
                            noFavoritesInGroup: '這個分組還沒有常用站牌喔！',
                            addFavoritesHint: '在路線動態頁面，長按或右鍵點擊站牌即可將其加入最愛。',
                            addedToGroup: '已加入到',
                            selectGroupTitle: '選擇分組',
                            manageGroupsTitle: '管理分組',
                            addNewGroup: '新增分組',
                            enterNewGroupName: '請輸入新分組的名稱：',
                            enterRename: '請輸入新的名稱：',
                            deleteGroupConfirm: '確定要刪除這個分組嗎？分組下的所有站牌將會被一併移除。',
                            groupNameExists: '分組名稱已存在！',
                            groupDeleted: '分組已刪除',
                            groupRenamed: '分組已重新命名',
                            groupAdded: '分組已新增',
                            manage: '管理',
                            all: '全部',
                            go: '出門',
                            home: '回家',
                            cancel: '取消',
                            confirm: '確認',
                            settingsTitle: '設定',
                            settingsSubtitle: '調整應用程式設定。',
                            appearance: '外觀',
                            darkMode: '深色模式',
                            splashScreen: '啟用啟動動畫',
                            showMap: '顯示地圖',
                            defaultStartPageTitle: '預設起始頁面',
                            defaultStartPageSubtitle: '選擇啟動時的頁面',
                            updateIntervalTitle: '自動更新頻率',
                            updateIntervalSubtitle: '設定動態更新秒數',
                            updateIntervalWarning: '高於30秒可能導致資訊過慢，請自行斟酌。',
                            languageSettings: '語言設定',
                            selectLanguage: '選擇語言',
                            about: '關於',
                            authorName: '作者：卓稟鈞 (Andrew)',
                            authorWebsite: '作者網站',
                            githubSource: 'GitHub 原始碼',
                            updateCountdown: '秒後更新',
                            navHome: '首頁',
                            navDynamic: '動態',
                            navFavorites: '最愛',
                            navMrt: '捷運',
                            navSettings: '設定',
                            noData: '無資料',
                            routeInfoNotFound: '找不到該路線的資訊，請確認路線代號是否正確。',
                            mrtTitle: '高雄捷運路網圖',
                            weatherTitle: '高雄天氣',
                            weatherLoadError: '無法載入天氣資料，請稍後再試。',
                            apparentTemperature: '體感溫度',
                            relativeHumidity: '相對濕度',
                            windSpeed: '風速',
                            weatherClear: '晴朗',
                            weatherMostlyClear: '主要晴朗',
                            weatherPartlyCloudy: '局部多雲',
                            weatherOvercast: '多雲',
                            weatherFog: '霧',
                            weatherDepositingFog: '結霜霧',
                            weatherDrizzleLight: '毛毛雨：小雨',
                            weatherDrizzleModerate: '毛毛雨：中雨',
                            weatherDrizzleDense: '毛毛雨：大雨',
                            weatherFreezingDrizzleLight: '凍毛毛雨：小雨',
                            weatherFreezingDrizzleDense: '凍毛毛雨：大雨',
                            weatherRainLight: '小雨',
                            weatherRainModerate: '中雨',
                            weatherRainHeavy: '大雨',
                            weatherFreezingRainLight: '凍雨：小雨',
                            weatherFreezingRainHeavy: '凍雨：大雨',
                            weatherSnowLight: '小雪',
                            weatherSnowModerate: '中雪',
                            weatherSnowHeavy: '大雪',
                            weatherSnowGrains: '雪粒',
                            weatherRainShowersLight: '陣雨：小雨',
                            weatherRainShowersModerate: '陣雨：中雨',
                            weatherRainShowersHeavy: '陣雨：大雨',
                            weatherSnowShowersLight: '陣雪：小雪',
                            weatherSnowShowersHeavy: '陣雪：大雪',
                            weatherThunderstorm: '雷暴',
                            weatherThunderstormHailLight: '雷暴伴隨小冰雹',
                            weatherThunderstormHailHeavy: '雷暴伴隨大冰雹',
                            weatherUnknown: '未知天氣',
                            announcementTitle: '訊息公告',
                            loadingAnnouncements: '正在載入訊息公告...',
                            noAnnouncements: '目前沒有任何訊息通知喔',
                            loadingRoutesError: '無法載入路線列表，請檢查您的網路連線。',
                            networkErrorCriticalTitle: '網路連線失敗',
                            networkErrorCriticalMessage: '無法獲取公車資料，功能將受限。請檢查網路後重試。',
                            networkErrorWarningTitle: '網路連線不穩定',
                            networkErrorWarningMessage: '無法更新至最新資料，目前顯示的是離線快取內容。',
                            networkErrorOfflineView: '網路連線失敗，無法顯示即時動態。',
                            offlineStatus: '離線'
                        },
                        en: {
                            appTitle: 'Kaohsiung Bus App',
                            appSubtitle: 'Your real-time bus partner',
                            routeSelectionTitle: 'Kaohsiung Bus Route Inquiry',
                            routeSelectionSubtitle: 'Use keyboard to find routes',
                            allRoutes: 'All Routes',
                            routeSearchPlaceholder: 'Enter route no.',
                            loadingRoutes: 'Loading all routes...',
                            noMatchingRoutes: 'No matching routes found.',
                            mainLine: 'Main Line',
                            expressLine: 'Express',
                            bus: 'Bus',
                            taxi: 'Taxi',
                            otherRoutes: 'Other',
                            reset: 'Reset',
                            errorTitle: 'Error!',
                            goDirection: 'To',
                            backDirection: 'To',
                            loadingBusData: 'Loading bus data...',
                            noBusDataForDirection: 'No bus information available for this direction.',
                            lastBusDeparted: 'Last Bus Departed',
                            approaching: 'Approaching',
                            arrivingSoon: 'Arriving Soon',
                            minutes: 'min',
                            unknownStation: 'Unknown Station',
                            removeFavorite: 'Remove Favorite',
                            addFavorite: 'Add Favorite',
                            favoritesTitle: 'Favorite Stops',
                            mapStopOrder: 'Stop Order:',
                            mapRealTimeStatus: 'Real-time Status:',
                            mapBusPlate: 'Plate No.:',
                            networkErrorOfflineView: 'Network connection failed. Cannot display real-time data.',
                            offlineStatus: 'Offline',
                            favoritesSubtitle: 'Tap to view details, long-press to remove, drag to reorder.',
                            noFavoritesYet: 'No favorite stops yet!',
                            noFavoritesInGroup: 'No favorite stops in this group yet!',
                            addFavoritesHint: 'On the dynamic route page, long-press or right-click a stop to add it to favorites.',
                            addedToGroup: 'Added to',
                            selectGroupTitle: 'Select Group',
                            manageGroupsTitle: 'Manage Groups',
                            addNewGroup: 'Add New Group',
                            enterNewGroupName: 'Please enter the new group name:',
                            enterRename: 'Please enter the new name:',
                            deleteGroupConfirm: 'Are you sure you want to delete this group? All stops within it will also be removed.',
                            groupNameExists: 'Group name already exists!',
                            groupDeleted: 'Group deleted',
                            groupRenamed: 'Group renamed',
                            groupAdded: 'Group added',
                            manage: 'Manage',
                            all: 'All',
                            go: 'Going Out',
                            home: 'Going Home',
                            cancel: 'Cancel',
                            confirm: 'Confirm',
                            settingsTitle: 'Settings',
                            settingsSubtitle: 'Adjust application settings.',
                            appearance: 'Appearance',
                            darkMode: 'Dark Mode',
                            splashScreen: 'Enable Startup Animation',
                            showMap: 'Show Map',
                            defaultStartPageTitle: 'Default Start Page',
                            defaultStartPageSubtitle: 'Select the page to show on launch',
                            updateIntervalTitle: 'Auto-Update Frequency',
                            updateIntervalSubtitle: 'Set dynamic update interval',
                            updateIntervalWarning: 'Intervals above 30s may result in outdated info. Use with caution.',
                            languageSettings: 'Language Settings',
                            selectLanguage: 'Select Language',
                            about: 'About',
                            authorName: 'Author: CHO, BING-JUN (Andrew)',
                            authorWebsite: "Author's Website",
                            githubSource: 'GitHub Source Code',
                            updateCountdown: 's to update',
                            navHome: 'Home',
                            navDynamic: 'Dynamic',
                            navFavorites: 'Favorites',
                            navMrt: 'MRT',
                            navSettings: 'Settings',
                            noData: 'No Data',
                            routeInfoNotFound: 'Route information not found. Please check if the route number is correct.',
                            mrtTitle: 'Kaohsiung MRT Map',
                            weatherTitle: 'Kaohsiung Weather',
                            weatherLoadError: 'Failed to load weather data, please try again later.',
                            apparentTemperature: 'Apparent Temp',
                            relativeHumidity: 'Humidity',
                            windSpeed: 'Wind Speed',
                            weatherClear: 'Clear',
                            weatherMostlyClear: 'Mostly Clear',
                            weatherPartlyCloudy: 'Partly Cloudy',
                            weatherOvercast: 'Overcast',
                            weatherFog: 'Fog',
                            weatherDepositingFog: 'Depositing Fog',
                            weatherDrizzleLight: 'Light Drizzle',
                            weatherDrizzleModerate: 'Moderate Drizzle',
                            weatherDrizzleDense: 'Dense Drizzle',
                            weatherFreezingDrizzleLight: 'Light Freezing Drizzle',
                            weatherFreezingDrizzleDense: 'Dense Freezing Drizzle',
                            weatherRainLight: 'Light Rain',
                            weatherRainModerate: 'Moderate Rain',
                            weatherRainHeavy: 'Heavy Rain',
                            weatherFreezingRainLight: 'Light Freezing Rain',
                            weatherFreezingRainHeavy: 'Heavy Freezing Rain',
                            weatherSnowLight: 'Light Snow',
                            weatherSnowModerate: 'Moderate Snow',
                            weatherSnowHeavy: 'Heavy Snow',
                            weatherSnowGrains: 'Snow Grains',
                            weatherRainShowersLight: 'Light Rain Showers',
                            weatherRainShowersModerate: 'Moderate Rain Showers',
                            weatherRainShowersHeavy: 'Heavy Rain Showers',
                            weatherSnowShowersLight: 'Light Snow Showers',
                            weatherSnowShowersHeavy: 'Heavy Snow Showers',
                            weatherThunderstorm: 'Thunderstorm',
                            weatherThunderstormHailLight: 'Thunderstorm with Light Hail',
                            weatherThunderstormHailHeavy: 'Thunderstorm with Heavy Hail',
                            weatherUnknown: 'Unknown Weather',
                            announcementTitle: 'Message Announcements',
                            loadingAnnouncements: 'Loading announcements...',
                            noAnnouncements: 'Currently no message notifications.',
                            loadingRoutesError: 'Could not load route list. Please check your network connection.',
                            networkErrorCriticalTitle: 'Network Connection Failed',
                            networkErrorCriticalMessage: 'Could not fetch bus data, functionality is limited. Please check your connection and retry.',
                            networkErrorWarningTitle: 'Unstable Network Connection',
                            networkErrorWarningMessage: 'Could not update to the latest data. Displaying offline cache.',
                            networkErrorOfflineView: 'Network connection failed. Cannot display real-time data.',
                            offlineStatus: 'Offline'
                        }
                    };
                    const categoryFilters = [
                        { prefix: '公車小黃', filterValue: '小黃', i18nKey: 'busTaxi' },
                        { prefix: '紅', filterValue: '紅', i18nKey: 'redLine' },
                        { prefix: '橘', filterValue: '橘', i18nKey: 'orangeLine' },
                        { prefix: '黃', filterValue: '黃', i18nKey: 'yellowLine' },
                        { prefix: '綠', filterValue: '綠', i18nKey: 'greenLine' },
                        { prefix: '其他', filterValue: '其他', i18nKey: 'otherRoutes' },
                        { prefix: '幹線', filterValue: '幹線', i18nKey: 'mainLine' },
                        { prefix: '快線', filterValue: 'E', i18nKey: 'expressLine' }
                    ];
                    const categoryDisplayMap = {
                        '紅': 'redLineShuttle',
                        '橘': 'orangeLineShuttle',
                        '黃': 'yellowLineShuttle',
                        '綠': 'greenLineShuttle',
                        '幹線': 'mainLineBus',
                        'E': 'expressLineBus',
                        '小黃': 'busTaxiBus',
                        '其他': 'otherRoutes'
                    };
                    translations.zh.redLineShuttle = '紅線接駁';
                    translations.zh.orangeLineShuttle = '橘線接駁';
                    translations.zh.yellowLineShuttle = '黃線接駁';
                    translations.zh.greenLineShuttle = '綠線接駁';
                    translations.zh.mainLineBus = '幹線公車';
                    translations.zh.expressLineBus = '快線公車';
                    translations.zh.busTaxiBus = '公車小黃';
                    translations.en.redLineShuttle = 'Red Line Shuttle';
                    translations.en.orangeLineShuttle = 'Orange Line Shuttle';
                    translations.en.yellowLineShuttle = 'Yellow Line Shuttle';
                    translations.en.greenLineShuttle = 'Green Line Shuttle';
                    translations.en.mainLineBus = 'Main Line Bus';
                    translations.en.expressLineBus = 'Express Line Bus';
                    translations.en.busTaxiBus = 'Bus Taxi';
                    translations.zh.busTaxi = '公車小黃';
                    translations.zh.redLine = '紅';
                    translations.zh.orangeLine = '橘';
                    translations.zh.yellowLine = '黃';
                    translations.zh.greenLine = '綠';
                    translations.en.busTaxi = 'Bus Taxi';
                    translations.en.redLine = 'Red';
                    translations.en.orangeLine = 'Orange';
                    translations.en.yellowLine = 'Yellow';
                    translations.en.greenLine = 'Green';
                    const GQL = {
                        QUERY_SIDE_ROUTES: `query QUERY_SIDE_ROUTES($lang: String!) {
                            routes(lang: $lang) {
                                edges {
                                    node {
                                        id, opType, id, seq, name, description
                                    }
                                }
                            }
                        }`,
                        QUERY_ROUTE_DETAILS: `
                            fragment estimateTimesFragment on EstimateTimeConnection { edges { node { id, goBack, comeTime, etas { busId, etaTime } } } }
                            fragment mapMarkerStationsFragment on RouteStationConnection { edges { goBack, orderNo, node { id, name, lat, lon } } }
                            fragment busesFragment on RouteBusConnection { edges { goBack, node { id, lat, lon } } }
                            query QUERY_ROUTE_FOR_MAP_CONTENT($routeId: Int!, $lang: String!) {
                                route(xno: $routeId, lang: $lang) {
                                    opType, departure, destination
                                    routePoint { go, back }
                                    estimateTimes { ...estimateTimesFragment }
                                    stations { ...mapMarkerStationsFragment }
                                    buses { ...busesFragment }
                                }
                            }
                        `,
                        QUERY_CLOGS: `query QUERY_CLOGS($routeId: Int!) {
                            clogMessages(xno: $routeId) {
                                edges {
                                    node {
                                        id, title, description
                                    }
                                }
                            }
                            abnormalMessages(xno: $routeId) {
                                edges {
                                    node {
                                        id, type, title, description
                                    }
                                }
                            }
                        }`
                    };

                    const getMarqueeSyncDelay = (contentEl, wasOverflowing) => {
                        const currentCard = contentEl.closest('.bus-card');
                        if (!currentCard) return '0s';
                        let referenceEl = null;

                        if (wasOverflowing) {
                            referenceEl = contentEl;
                        } 
                        
                        if (!referenceEl) {
                            let prevCard = currentCard.previousElementSibling;
                            while (prevCard) {
                                const potentialRef = prevCard.querySelector('.marquee-text.is-overflowing > *');
                                if (potentialRef) { referenceEl = potentialRef; break; }
                                prevCard = prevCard.previousElementSibling;
                            }
                        }
                        
                        if (!referenceEl) {
                            let nextCard = currentCard.nextElementSibling;
                            while (nextCard) {
                                const potentialRef = nextCard.querySelector('.marquee-text.is-overflowing > *');
                                if (potentialRef) { referenceEl = potentialRef; break; }
                                nextCard = nextCard.nextElementSibling;
                            }
                        }

                        if (!referenceEl) return '0s';

                        try {
                            const animations = referenceEl.getAnimations();
                            const marqueeAnimation = animations.find(anim => anim.animationName === 'marquee-scroll');
                            if (!marqueeAnimation) return '0s';

                            const timing = marqueeAnimation.effect.getComputedTiming();
                            const duration = timing.duration;
                            if (isNaN(duration) || duration === 0) return '0s';

                            const progress = (marqueeAnimation.currentTime / duration) % 1;
                            const newDuration = parseFloat(contentEl.style.animationDuration);
                            
                            return `-${progress * newDuration}s`;
                        } catch (e) {
                            console.error("Error calculating marquee delay:", e);
                            return '0s';
                        }
                    };

                    const checkMarquee = (contentEl) => {
                        const marqueeText = contentEl.parentElement;
                        const container = marqueeText.parentElement;
                        const currentText = contentEl.textContent.trim();
                        const wasOverflowing = marqueeText.classList.contains('is-overflowing');

                        const forceScrollInEnglish = [
                            translations.en.approaching, 
                            translations.en.arrivingSoon,
                            translations.en.lastBusDeparted
                        ];
                        const forceMarquee = currentLang === 'en' && forceScrollInEnglish.includes(currentText);
                        const shouldMarquee = contentEl.scrollWidth > container.clientWidth || forceMarquee;
                        
                        if (shouldMarquee) {
                            const duration = Math.max(2.5, Math.min(15, contentEl.scrollWidth / MARQUEE_SPEED_PPS));
                            contentEl.style.animationDuration = `${duration}s`;
                            
                            const delay = getMarqueeSyncDelay(contentEl, wasOverflowing);
                            contentEl.style.animationDelay = delay;
                            
                            marqueeText.classList.add('is-overflowing');
                            if (!contentEl.querySelector('.marquee-inner')) {
                                contentEl.innerHTML = `<span class="marquee-inner">${currentText}</span><span class="marquee-inner">${currentText}</span>`;
                            }
                        } else {
                            if (wasOverflowing) {
                                marqueeText.classList.remove('is-overflowing');
                                contentEl.innerHTML = currentText;
                                contentEl.style.animationDuration = '';
                                contentEl.style.animationDelay = '';
                            }
                        }
                    };

                    const scheduleMarqueeCheck = (element) => {
                        if(!element) return;
                        if (element._marqueeCheckId) cancelAnimationFrame(element._marqueeCheckId);
                        element._marqueeCheckId = requestAnimationFrame(() => checkMarquee(element));
                    };
                    
                    function startInfoCycler() {
                        if (infoCyclerInterval) clearInterval(infoCyclerInterval);
                        infoCyclerInterval = setInterval(() => {
                            document.querySelectorAll('.info-cycler').forEach(cycler => {
                                const items = Array.from(cycler.querySelectorAll('.cycler-item')).filter(it => it.style.display !== 'none');
                                if (items.length < 2) return;
                                let currentIndex = items.findIndex(item => item.classList.contains('active'));
                                if (currentIndex !== -1) {
                                    items[currentIndex].classList.remove('active');
                                    const nextIndex = (currentIndex + 1) % items.length;
                                    items[nextIndex].classList.add('active');
                                }
                            });
                        }, 4000);
                    }

                    function decodePolyline(t){for(var n,o,u=0,l=0,r=0,d= [],h=0,i=0,a=null,c=Math.pow(10,5);u<t.length;){a=null,h=0,i=0;do a=t.charCodeAt(u++)-63,i|=(31&a)<<h,h+=5;while(a>=32);n=1&i?~(i>>1):i>>1,h=i=0;do a=t.charCodeAt(u++)-63,i|=(31&a)<<h,h+=5;while(a>=32);o=1&i?~(i>>1):i>>1,l+=n,r+=o,d.push([l/c,r/c])}return d}
                    function findClosestPointOnPolyline(point, polyline) {
                        let minDistanceSquared = Infinity;
                        let closestPoint = null;
                    
                        if (!map || !polyline || polyline.length < 2) {
                            return L.latLng(point);
                        }
                    
                        const pointProjected = map.project(point);
                    
                        for (let i = 0; i < polyline.length - 1; i++) {
                            const p1 = L.latLng(polyline[i]);
                            const p2 = L.latLng(polyline[i+1]);
                    
                            const p1Projected = map.project(p1);
                            const p2Projected = map.project(p2);
                    
                            const segmentLengthSquared = p1Projected.distanceTo(p2Projected) ** 2;
                    
                            if (segmentLengthSquared === 0) continue;
                    
                            const t = ((pointProjected.x - p1Projected.x) * (p2Projected.x - p1Projected.x) + (pointProjected.y - p1Projected.y) * (p2Projected.y - p1Projected.y)) / segmentLengthSquared;
                    
                            let projectedSegmentPoint;
                            if (t < 0) {
                                projectedSegmentPoint = p1Projected;
                            } else if (t > 1) {
                                projectedSegmentPoint = p2Projected;
                            } else {
                                projectedSegmentPoint = L.point(
                                    p1Projected.x + t * (p2Projected.x - p1Projected.x),
                                    p1Projected.y + t * (p2Projected.y - p1Projected.y)
                                );
                            }
                    
                            const distanceSquared = pointProjected.distanceTo(projectedSegmentPoint) ** 2;
                    
                            if (distanceSquared < minDistanceSquared) {
                                minDistanceSquared = distanceSquared;
                                closestPoint = projectedSegmentPoint;
                            }
                        }
                        
                        return closestPoint ? map.unproject(closestPoint) : L.latLng(point);
                    }
                    function updateNavHighlight() {
                        document.querySelectorAll('#mainNav button').forEach(button => {
                            button.classList.remove('active-nav');
                        });
                        let navButtonId = activePage.replace('Page', '');
                        if (activePage === 'routeSelectionPage' || activePage === 'busTrackerPage') {
                            navButtonId = 'dynamic';
                        }
                        const navButton = document.querySelector(`#mainNav button[data-page="${navButtonId}"]`);
                        if (navButton) {
                            navButton.classList.add('active-nav');
                        }
                    }
                    function checkMarqueeOverflow(container, textElement, originalText) {
                        if (!container || !textElement) return;
                        const oldText = textElement.dataset.originalText;
                        if (oldText === originalText && textElement.classList.contains('is-overflowing')) {
                            return; 
                        }
                        textElement.dataset.originalText = originalText;
                        container.style.flexGrow = '1';
                        textElement.classList.remove('is-overflowing');
                        textElement.style.animation = 'none';
                        textElement.textContent = originalText; 
                        requestAnimationFrame(() => {
                            const containerWidth = container.clientWidth;
                            const textWidth = textElement.scrollWidth;
                            const isOverflowing = textWidth > containerWidth;
                            if (isOverflowing) {
                                const gap = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
                                const unitText = `${gap}${originalText}`;
                                const fullMarqueeText = `${unitText}${unitText}`; 
                                textElement.innerHTML = fullMarqueeText;
                                requestAnimationFrame(() => {
                                    const scrollWidth = textElement.scrollWidth / 2; 
                                    const duration = scrollWidth / 40; 
                                    textElement.style.animation = `marquee-scroll ${Math.max(8, duration)}s linear infinite`;
                                    textElement.classList.add('is-overflowing');
                                });
                            } else {
                                container.style.flexGrow = '0'; 
                                textElement.textContent = originalText; 
                                textElement.classList.remove('is-overflowing');
                            }
                        });
                    }
                    function updateMrtIframeSrc() {
                        const isDarkMode = body.classList.contains('dark-mode');
                        const darkSrc = 'https://krtc.pages.dev/?mode=dark';
                        const lightSrc = 'https://krtc.pages.dev/';
                        const newSrc = isDarkMode ? darkSrc : lightSrc;
                        if (mrtIframeLoaded) {
                            mrtIframe.src = newSrc;
                        }
                    }
                    function applyInitialTheme() {
                        const isDarkMode = localStorage.getItem('darkMode') === 'true';
                        darkModeToggle.checked = isDarkMode;
                        if (isDarkMode) {
                            body.classList.add('dark-mode');
                        } else {
                            body.classList.remove('dark-mode');
                        }
                        updateMrtIframeSrc();
                    }
                    function updateTrackerLayout() {
                        const mapEnabled = localStorage.getItem('mapDisplayEnabled') !== 'false';
                        if (mapEnabled) {
                            busTrackerPage.classList.remove('map-hidden');
                        } else {
                            busTrackerPage.classList.add('map-hidden');
                        }
                        if (map) {
                            map.invalidateSize();
                        }
                    }
                    async function setLanguage(lang) {
                        if (lang === currentLang) return;
                        currentLang = lang;
                        localStorage.setItem('lang', lang);
                        applyTranslations();
                        routeDataLang = null;
                        weatherDataLoaded = false;
                        announcementsDataLoaded = false;
                        switch (activePage) {
                            case 'routeSelectionPage':
                                await initRouteSelection();
                                break;
                            case 'busTrackerPage':
                                if (currentRouteId) {
                                    await loadBusData(currentRouteId, true); 
                                }
                                break;
                            case 'favoriteStationsPage':
                                await displayFavoriteStations();
                                break;
                            case 'homePage':
                                await fetchWeather();
                                await fetchAnnouncements();
                                break;
                        }
                    }
                    function applyTranslations() {
                        document.querySelectorAll('[data-i18n]').forEach(element => {
                            const key = element.dataset.i18n;
                            if (translations[currentLang] && translations[currentLang][key]) {
                                if (element.classList.contains('static-text')) {
                                    element.textContent = translations[currentLang][key] + " ";
                                } else if (element.tagName === 'OPTION') {
                                    element.textContent = translations[currentLang][key];
                                } else {
                                    element.textContent = translations[currentLang][key];
                                }
                            }
                        });
                        routeSearchInput.placeholder = translations[currentLang].routeSearchPlaceholder;
                        if (selectedCategoryPrefix) {
                            const categoryFilter = categoryFilters.find(cat => cat.prefix === selectedCategoryPrefix);
                            if (categoryFilter && translations[currentLang][categoryDisplayMap[categoryFilter.filterValue]]) {
                                categoryDisplay.textContent = translations[currentLang][categoryDisplayMap[categoryFilter.filterValue]];
                            } else {
                                categoryDisplay.textContent = translations[currentLang].allRoutes;
                            }
                        } else {
                            categoryDisplay.textContent = translations[currentLang].allRoutes;
                        }
                        filterKeyboard.querySelectorAll('button[data-type="category"]').forEach(button => {
                            const filterValue = button.dataset.filter;
                            const categoryFilter = categoryFilters.find(cat => cat.filterValue === filterValue);
                            if (categoryFilter && translations[currentLang][categoryFilter.i18nKey]) {
                                if (filterValue === '小黃') {
                                    button.querySelector('.bus-text').textContent = translations[currentLang].bus;
                                    button.querySelector('.taxi-text').textContent = translations[currentLang].taxi;
                                } else {
                                    button.textContent = translations[currentLang][categoryFilter.i18nKey];
                                }
                            }
                        });
                        if (countdownTimer) {
                            countdownTimer.updateDisplay();
                        }
                    }
                    async function fetchAPI(query, variables) {
                        try {
                            const response = await fetch(API_URL, {
                                method: 'POST',
                                headers: HEADERS,
                                body: JSON.stringify({ query, variables })
                            });
                            if (!response.ok) throw new Error(`${translations[currentLang].errorTitle} HTTP error! status: ${response.status}`);
                            return await response.json();
                        } catch (error) {
                            console.error("API Fetch Error:", error);
                            throw error;
                        }
                    }
                    
                    function showToast(message, type = 'info', duration = 3000) {
                        const toast = document.createElement('div');
                        let bgColor, textColor, icon;

                        switch (type) {
                            case 'error':
                                bgColor = 'bg-red-500 dark:bg-red-700';
                                textColor = 'text-white';
                                icon = 'error_outline';
                                break;
                            case 'warning':
                                bgColor = 'bg-yellow-500 dark:bg-yellow-600';
                                textColor = 'text-white dark:text-slate-900';
                                icon = 'warning_amber';
                                break;
                            default:
                                bgColor = 'bg-slate-700 dark:bg-slate-200';
                                textColor = 'text-white dark:text-slate-800';
                                icon = 'info_outline';
                                break;
                        }

                        toast.className = `flex items-center gap-3 w-auto max-w-sm p-3 rounded-lg shadow-lg pointer-events-auto transition-all duration-300 transform translate-y-4 opacity-0 ${bgColor} ${textColor}`;
                        toast.innerHTML = `
                            <span class="material-icons-outlined">${icon}</span>
                            <p class="text-sm font-medium">${message}</p>
                        `;
                        
                        toastContainer.appendChild(toast);
                        
                        // Animate in
                        setTimeout(() => {
                            toast.classList.remove('translate-y-4', 'opacity-0');
                        }, 10);

                        // Animate out
                        setTimeout(() => {
                            toast.classList.add('opacity-0');
                            toast.addEventListener('transitionend', () => toast.remove());
                        }, duration);
                    }

                    async function fetchWithRetry(query, variables, retries = 1, delay = 2000) {
                        try {
                            // Use the original fetchAPI function for the actual request
                            return await fetchAPI(query, variables);
                        } catch (error) {
                            if (retries > 0 && navigator.onLine) {
                                await new Promise(resolve => setTimeout(resolve, delay));
                                return await fetchWithRetry(query, variables, retries - 1, delay);
                            } else {
                                // Re-throw the error after all retries fail or if offline
                                throw error;
                            }
                        }
                    }

                    function customPrompt(title, message, defaultValue = '') {
                        const modalHash = `#prompt/${Date.now()}`;
                        history.pushState({ modal: 'prompt', page: activePage }, '', modalHash);
                        customPromptTitle.textContent = title;
                        customPromptMessage.textContent = message;
                        customPromptInput.value = defaultValue;
                        customPromptModal.classList.add('show');
                        customPromptInput.focus();
                        return new Promise(resolve => {
                            resolveCustomPrompt = resolve;
                            const cleanup = (result) => {
                                if (window.location.hash === modalHash && history.state?.modal === 'prompt') {
                                    history.back();
                                }
                                customPromptModal.classList.remove('show');
                                resolve(result);
                                removeEventListeners();
                                resolveCustomPrompt = null;
                            };
                            const handleConfirm = () => cleanup(customPromptInput.value);
                            const handleCancel = () => cleanup(null);
                            const handleKeyDown = (e) => {
                                if (e.key === 'Enter') handleConfirm();
                                else if (e.key === 'Escape') handleCancel();
                            };
                            const removeEventListeners = () => {
                                customPromptConfirmBtn.removeEventListener('click', handleConfirm);
                                customPromptCancelBtn.removeEventListener('click', handleCancel);
                                customPromptInput.removeEventListener('keydown', handleKeyDown);
                            };
                            customPromptConfirmBtn.addEventListener('click', handleConfirm);
                            customPromptCancelBtn.addEventListener('click', handleCancel);
                            customPromptInput.addEventListener('keydown', handleKeyDown);
                        });
                    }
                    function customConfirm(title, message) {
                        const modalHash = `#confirm/${Date.now()}`;
                        history.pushState({ modal: 'confirm', page: activePage }, '', modalHash);
                        customConfirmTitle.textContent = title;
                        customConfirmMessage.textContent = message;
                        customConfirmModal.classList.add('show');
                        return new Promise(resolve => {
                            resolveCustomConfirm = resolve;
                            const cleanup = (result) => {
                                 if (window.location.hash === modalHash && history.state?.modal === 'confirm') {
                                    history.back();
                                }
                                customConfirmModal.classList.remove('show');
                                resolve(result);
                                removeEventListeners();
                                resolveCustomConfirm = null;
                            };
                            const handleConfirm = () => cleanup(true);
                            const handleCancel = () => cleanup(false);
                            const removeEventListeners = () => {
                                customConfirmConfirmBtn.removeEventListener('click', handleConfirm);
                                customConfirmCancelBtn.removeEventListener('click', handleCancel);
                            };
                            customConfirmConfirmBtn.addEventListener('click', handleConfirm);
                            customConfirmCancelBtn.addEventListener('click', handleCancel);
                        });
                    }
                    function loadFavorites() {
                        try {
                            let data = localStorage.getItem('favoriteData');
                            if (data) {
                                favoriteData = JSON.parse(data);
                                if (!favoriteData.groupOrder) {
                                    console.log("Migrating favorites to include new ordering system.");
                                    favoriteData.groupOrder = {};
                                    favoriteData.groupOrder.all = favoriteData.favorites.map(f => `${f.routeId}-${f.stationId}-${f.direction}`);
                                    favoriteData.groups.forEach(group => {
                                        const groupId = group.id;
                                        favoriteData.groupOrder[groupId] = favoriteData.favorites
                                            .filter(f => f.groupId === groupId)
                                            .map(f => `${f.routeId}-${f.stationId}-${f.direction}`);
                                    });
                                    saveFavorites();
                                }
                            } else {
                                favoriteData = {
                                    groups: [],
                                    favorites: [],
                                    groupOrder: { all: [] }
                                };
                            }
                        } catch (e) {
                            console.error("Error loading favorites from localStorage:", e);
                            favoriteData = {
                                groups: [],
                                favorites: [],
                                groupOrder: { all: [] }
                            };
                        }
                    }
                    function saveFavorites() {
                        try {
                            localStorage.setItem('favoriteData', JSON.stringify(favoriteData));
                        } catch (e) {
                            console.error("Error saving favorites to localStorage:", e);
                        }
                    }
                    function isFavorite(routeId, stationId, direction) {
                        return favoriteData.favorites.some(fav =>
                            fav.routeId === Number(routeId) &&
                            fav.stationId === String(stationId) &&
                            fav.direction === Number(direction)
                        );
                    }
                    function addFavorite(stationData, groupId) {
                        const { routeId, stationId, direction } = stationData;
                        if (!isFavorite(routeId, stationId, direction)) {
                            const newFavorite = { ...stationData, groupId };
                            favoriteData.favorites.push(newFavorite);
                            const favoriteId = `${newFavorite.routeId}-${newFavorite.stationId}-${newFavorite.direction}`;
                            if (!favoriteData.groupOrder.all) favoriteData.groupOrder.all = [];
                            favoriteData.groupOrder.all.push(favoriteId);
                            if (groupId && !favoriteData.groupOrder[groupId]) {
                                favoriteData.groupOrder[groupId] = [];
                            }
                            if (groupId) {
                                favoriteData.groupOrder[groupId].push(favoriteId);
                            }
                            saveFavorites();
                            if (busTrackerPage.classList.contains('active')) {
                                loadBusData(currentRouteId, false);
                            }
                        }
                    }
                    function removeFavorite(stationData) {
                        const { routeId, stationId, direction } = stationData;
                        const favoriteId = `${routeId}-${stationId}-${direction}`;
                        const index = favoriteData.favorites.findIndex(fav =>
                            fav.routeId === Number(routeId) &&
                            fav.stationId === String(stationId) &&
                            fav.direction === Number(direction)
                        );
                        if (index > -1) {
                            favoriteData.favorites.splice(index, 1);
                            if (favoriteData.groupOrder) {
                                Object.keys(favoriteData.groupOrder).forEach(key => {
                                    const orderIndex = favoriteData.groupOrder[key].indexOf(favoriteId);
                                    if (orderIndex > -1) {
                                        favoriteData.groupOrder[key].splice(orderIndex, 1);
                                    }
                                });
                            }
                            saveFavorites();
                            if (activePage === 'favoriteStationsPage') {
                                displayFavoriteStations();
                            } else if (busTrackerPage.classList.contains('active')) {
                                 loadBusData(currentRouteId, false);
                            }
                        }
                    }
                    function positionAndShowActionButton(clientX, clientY) {
                        favoriteActionButton.classList.remove('hidden');
                        favoriteActionButton.classList.add('show');
                        const buttonWidth = favoriteActionButton.offsetWidth;
                        const buttonHeight = favoriteActionButton.offsetHeight;
                        let left = clientX; let top = clientY;
                        if (left + buttonWidth > window.innerWidth - 10) left = window.innerWidth - buttonWidth - 10;
                        if (top + buttonHeight > window.innerHeight - 10) top = window.innerHeight - buttonHeight - 10;
                        if (left < 10) left = 10; if (top < 10) top = 10;
                        favoriteActionButton.style.left = `${left}px`;
                        favoriteActionButton.style.top = `${top}px`;
                        favoriteButtonHideTimeout = setTimeout(() => { hideFavoriteButton(); }, 4000);
                    }
                    function showFavoriteButton(stationData, clientX, clientY) {
                        clearTimeout(favoriteButtonHideTimeout);
                        currentStationContext = stationData;
                        const isCurrentlyFavorite = isFavorite(stationData.routeId, stationData.stationId, stationData.direction);
                        if (isCurrentlyFavorite) {
                            favoriteActionIcon.textContent = 'favorite';
                            favoriteActionText.textContent = translations[currentLang].removeFavorite;
                        } else {
                            favoriteActionIcon.textContent = 'favorite_border';
                            favoriteActionText.textContent = translations[currentLang].addFavorite;
                        }
                        positionAndShowActionButton(clientX, clientY);
                    }
                    function hideFavoriteButton() {
                        clearTimeout(favoriteButtonHideTimeout);
                        favoriteActionButton.classList.remove('show');
                        favoriteActionButton.addEventListener('transitionend', () => {
                            favoriteActionButton.classList.add('hidden');
                        }, { once: true });
                    }
                    async function showPage(pageId, pushState = true) {
                        if (activePage === pageId && document.getElementById(pageId)?.classList.contains('active')) {
                            if (pageId === 'routeSelectionPage') {
                                resetSearch();
                                await initRouteSelection();
                            }
                            return; 
                        }
                        if (favoriteUpdateInterval) {
                            clearInterval(favoriteUpdateInterval);
                            favoriteUpdateInterval = null;
                        }
                        if (infoCyclerInterval) {
                            clearInterval(infoCyclerInterval);
                            infoCyclerInterval = null;
                        }
                        const oldPageId = activePage;
                        if (pushState) {
                             const state = { page: pageId };
                             let pageName = pageId.replace('Page', '');
                             if (pageId === 'routeSelectionPage') pageName = 'dynamic';
                             if (pageId === 'busTrackerPage') pageName = 'tracker';
                             let url = `?page=${pageName}`;
                             if (pageId === 'busTrackerPage' && currentRouteId) {
                                state.routeId = currentRouteId;
                                url += `&route=${currentRouteId}`;
                             }
                             history.pushState(state, '', url);
                        } else if (pageId === 'homePage' && oldPageId !== 'homePage' && !window.location.search.includes('page=home')) {
                            history.pushState({ page: 'homePage' }, '', '?page=home');
                        }
                        
                        lastPage = activePage;
                        activePage = pageId;
                        document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
                        const newPage = document.getElementById(pageId);
                        if (newPage) {
                            newPage.classList.add('active');
                        } else {
                            console.error(`Page with ID "${pageId}" not found.`);
                            document.getElementById('homePage').classList.add('active');
                            activePage = 'homePage';
                        }
                        
                        if (pageId === 'routeSelectionPage') {
                            resetSearch();
                            filterKeyboardContainer.style.display = 'block';
                            updateCountdownButton.style.display = 'none';
                            adjustContentPadding();
                        } else if (pageId === 'busTrackerPage') {
                            updateTrackerLayout();
                            filterKeyboardContainer.style.display = 'none';
                            if (navigator.onLine) {
                                updateCountdownButton.style.display = 'flex';
                            } else {
                                updateCountdownButton.style.display = 'none';
                            }
                            if(map) {
                                setTimeout(() => map.invalidateSize(), 10);
                            }
                        } else {
                            filterKeyboardContainer.style.display = 'none';
                            updateCountdownButton.style.display = 'none';
                            const container = document.querySelector(`#${pageId} .container`);
                            if(container) {
                                /* container.style.paddingBottom = '90px'; */ /* CSS handled */
                            }
                        }
                        updateNavHighlight();
                        if (pageId === 'favoriteStationsPage') {
                            await displayFavoriteStations();
                            if (!favoriteUpdateInterval) {
                                favoriteUpdateInterval = setInterval(refreshFavoriteTimes, 30000);
                            }
                        }
                        else if (pageId === 'homePage') {
                            if (!weatherDataLoaded) fetchWeather();
                            if (!announcementsDataLoaded) fetchAnnouncements();
                        }
                        else if (pageId === 'mrtPage' && !mrtIframeLoaded) {
                            mrtIframeLoaded = true;
                            updateMrtIframeSrc();
                        }
                    }
                    function resetSearch() {
                        selectedCategoryPrefix = '';
                        routeSearchInput.value = '';
                        categoryDisplay.textContent = translations[currentLang].allRoutes;
                        if (allRoutes.length > 0) {
                           applySearch('');
                        }
                    }
                    function displayNetworkErrorAnnouncement(isCritical) {
                        const announcementContent = document.getElementById('announcementContent');
                        const announcementLoading = document.getElementById('announcementLoading');
                        const noAnnouncementsMessage = document.getElementById('noAnnouncementsMessage');
                        announcementLoading.style.display = 'none';
                        noAnnouncementsMessage.style.display = 'none';
                        const existingError = announcementContent.querySelector('.error-announcement');
                        if (existingError) return;
                        const errorCard = document.createElement('div');
                        errorCard.className = 'error-announcement announcement-item bg-red-100 dark:bg-red-900 p-3 rounded-lg shadow-sm mb-3 border border-red-300 dark:border-red-700';
                        const title = isCritical
                            ? (translations[currentLang].networkErrorCriticalTitle)
                            : (translations[currentLang].networkErrorWarningTitle);
                        const message = isCritical
                            ? (translations[currentLang].networkErrorCriticalMessage)
                            : (translations[currentLang].networkErrorWarningMessage);
                        errorCard.innerHTML = `
                            <h3 class="font-semibold text-red-800 dark:text-red-200 flex items-center">
                                <span class="material-icons-outlined mr-2">wifi_off</span>
                                ${title}
                            </h3>
                            <p class="text-sm text-red-700 dark:text-red-300 mt-1">${message}</p>
                        `;
                        announcementContent.prepend(errorCard);
                    }
                    async function initRouteSelection() {
                        try {
                            if (allRoutes.length > 0 && routeDataLang === currentLang) {
                                displayInitialPrompt();
                                return;
                            }
                            initialLoading.style.display = 'block';
                            routeListContainer.innerHTML = '';
                            const data = await fetchAPI(GQL.QUERY_SIDE_ROUTES, { lang: currentLang });
                            allRoutes = data.data.routes.edges
                                .map(edge => edge.node)
                                .filter(route => route.id !== 0)
                                .sort((a, b) => a.seq - b.seq);
                            try {
                                localStorage.setItem('cachedRoutes', JSON.stringify(allRoutes));
                                localStorage.setItem('cachedRoutesLang', currentLang);
                            } catch (e) {
                                console.error("Error saving routes to localStorage", e);
                            }
                            displayInitialPrompt();
                        } catch (fetchError) {
                            console.warn("API fetch failed. Attempting to load from cache.", fetchError);
                            try {
                                const cachedRoutes = localStorage.getItem('cachedRoutes');
                                const cachedRoutesLang = localStorage.getItem('cachedRoutesLang');
                                if (cachedRoutes && cachedRoutesLang === currentLang) {
                                    allRoutes = JSON.parse(cachedRoutes);
                                    displayInitialPrompt();
                                    displayNetworkErrorAnnouncement(false); 
                                } else {
                                    throw new Error("No valid cached data available for the current language.");
                                }
                            } catch (cacheError) {
                                console.error("Cache also failed. App will start in a limited state.", cacheError);
                                allRoutes = []; 
                                displayNetworkErrorAnnouncement(true); 
                                routeListContainer.innerHTML = `<p class="text-center py-10 text-red-500">${translations[currentLang].loadingRoutesError}</p>`;
                            }
                        } finally {
                            initialLoading.style.display = 'none';
                            routeDataLang = currentLang;
                        }
                    }
                    function displayInitialPrompt() {
                        routeListContainer.innerHTML = `
                            <div id="initialPrompt" class="text-center col-span-full py-10 text-slate-500">
                                <p class="text-lg">${translations[currentLang].routeSelectionSubtitle}</p>
                            </div>`;
                        noResultsMessage.style.display = 'none';
                    }
                    function displayRoutes(routes) {
                        routeListContainer.innerHTML = '';
                        if (routes.length === 0 && allRoutes.length > 0) { 
                            noResultsMessage.style.display = 'block';
                        } else {
                            noResultsMessage.style.display = 'none';
                        }
                        routes.forEach(route => {
                            const card = document.createElement('div');
                            card.className = 'route-card p-4 bg-white rounded-lg shadow-md cursor-pointer border-l-4 border-transparent hover:bg-slate-50 dark:hover:bg-slate-700 transition-colors';
                            card.dataset.routeId = route.id;
                            card.dataset.routeName = route.name;
                            card.dataset.routeDesc = route.description;
                            card.innerHTML = `
                                <h3 class="font-bold text-lg text-slate-800 dark:text-slate-200">${route.name}</h3>
                                <p class="text-sm text-slate-600 dark:text-slate-400 mt-1">${route.description || '&nbsp;'}</p>
                            `;
                            card.addEventListener('click', () => {
                                navigateToTracker(card.dataset.routeId, card.dataset.routeName, card.dataset.routeDesc);
                            });
                            routeListContainer.appendChild(card);
                        });
                    }
                    function applySearch(searchTerm) {
                        const lowerCaseTerm = searchTerm.toLowerCase().trim();
                        if (!lowerCaseTerm) {
                            if (allRoutes.length === 0) {
                                 routeListContainer.innerHTML = `<p class="text-center py-10 text-red-500">${translations[currentLang].loadingRoutesError}</p>`;
                            } else {
                                displayInitialPrompt();
                            }
                            return;
                        }
                        let filteredRoutes = [...allRoutes];
                        let categoryMatched = false;
                        let remainingSearchTerm = lowerCaseTerm;
                        for (const category of categoryFilters) {
                            const lowerCasePrefix = translations[currentLang][category.i18nKey] ? translations[currentLang][category.i18nKey].toLowerCase() : category.prefix.toLowerCase();
                            if (lowerCaseTerm.startsWith(lowerCasePrefix)) {
                                const filterVal = category.filterValue;
                                if (filterVal === '其他') {
                                    filteredRoutes = allRoutes.filter(route =>
                                        route.name.toLowerCase().includes('joy') ||
                                        route.name.toLowerCase().includes('dashu blessing bus') ||
                                        route.name.toLowerCase().includes('大樹祈福')
                                    );
                                } else if (filterVal === 'E') {
                                    filteredRoutes = allRoutes.filter(route => route.name.toLowerCase().startsWith('e'));
                                } else if (filterVal === '小黃') {
                                    filteredRoutes = allRoutes.filter(route => route.opType === 9);
                                } else if (filterVal === '幹線') {
                                    const keyword = currentLang === 'en' ? 'main line' : '幹線';
                                    filteredRoutes = allRoutes.filter(route => route.name.toLowerCase().includes(keyword));
                                } else if (['紅', '橘', '黃', '綠'].includes(filterVal)) {
                                    const keyword = translations[currentLang][category.i18nKey].toLowerCase();
                                     if (currentLang === 'zh' && filterVal === '黃') {
                                        filteredRoutes = allRoutes.filter(route => route.name.includes(keyword) && route.opType !== 9);
                                    } else {
                                        filteredRoutes = allRoutes.filter(route => route.name.toLowerCase().includes(keyword));
                                    }
                                }
                                remainingSearchTerm = lowerCasePrefix.length > 0 ? lowerCaseTerm.substring(lowerCasePrefix.length).trim() : lowerCaseTerm;
                                categoryMatched = true;
                                break;
                            }
                        }
                        if (remainingSearchTerm) {
                            const finalFilterTarget = categoryMatched ? filteredRoutes : allRoutes;
                            filteredRoutes = finalFilterTarget.filter(route =>
                                route.name.toLowerCase().includes(remainingSearchTerm) ||
                                (route.description && route.description.toLowerCase().includes(remainingSearchTerm))
                            );
                        }
                        displayRoutes(filteredRoutes);
                    }
                    function updateDirectionButtons() {
                        if (!currentRouteData) {
                            goDirectionButton.parentElement.style.display = 'none';
                            return;
                        }
                        goDirectionButton.parentElement.style.display = 'flex';
                        const goStaticText = goDirectionButton.querySelector('.static-text');
                        const goMarqueeContainer = goDirectionButton.querySelector('.marquee-container');
                        const goMarqueeText = goDirectionButton.querySelector('.marquee-text');
                        const backStaticText = backDirectionButton.querySelector('.static-text');
                        const backMarqueeContainer = backDirectionButton.querySelector('.marquee-container');
                        const backMarqueeText = backDirectionButton.querySelector('.marquee-text');
                        
                        goStaticText.textContent = `${translations[currentLang].goDirection} `;
                        backStaticText.textContent = `${translations[currentLang].backDirection} `;
                        
                        const goText = currentRouteData.destination;
                        const backText = currentRouteData.departure;
                        
                        checkMarqueeOverflow(goMarqueeContainer, goMarqueeText, goText);
                        checkMarqueeOverflow(backMarqueeContainer, backMarqueeText, backText);

                        if (currentDirection === 1) {
                            goDirectionButton.classList.add('bg-blue-500', 'text-white');
                            goDirectionButton.classList.remove('bg-transparent', 'text-blue-500');
                            backDirectionButton.classList.add('bg-transparent', 'text-blue-500');
                            backDirectionButton.classList.remove('bg-blue-500', 'text-white');
                            if(map) {
                                goLayerGroup.addTo(map); backLayerGroup.removeFrom(map);
                                goBusLayerGroup.addTo(map); backBusLayerGroup.removeFrom(map);
                            }
                        } else {
                            backDirectionButton.classList.add('bg-blue-500', 'text-white');
                            backDirectionButton.classList.remove('bg-transparent', 'text-blue-500');
                            goDirectionButton.classList.add('bg-transparent', 'text-blue-500');
                            goDirectionButton.classList.remove('bg-blue-500', 'text-white');
                             if(map) {
                                backLayerGroup.addTo(map); goLayerGroup.removeFrom(map);
                                backBusLayerGroup.addTo(map); goBusLayerGroup.removeFrom(map);
                            }
                        }
                    }

                    function handleDirectionToggle(newDirection) {
                        if (newDirection === currentDirection || !currentRouteData || isAnimatingDirection) {
                            return;
                        }
                        isAnimatingDirection = true;
                        const outgoingList = (currentDirection === 1) ? stationListGo : stationListBack;
                        const incomingList = (newDirection === 1) ? stationListGo : stationListBack;
                        const slideOutClass = newDirection > currentDirection ? 'slide-out-left' : 'slide-out-right';
                        const slideInClass = newDirection > currentDirection ? 'slide-in-from-right' : 'slide-in-from-left';
                        
                        incomingList.classList.remove('hidden');
                        outgoingList.classList.add(slideOutClass);
                        incomingList.classList.add(slideInClass);
                        
                        currentDirection = newDirection;
                        updateDirectionButtons();

                        setTimeout(() => {
                            outgoingList.classList.add('hidden');
                            outgoingList.classList.remove(slideOutClass);
                            incomingList.classList.remove(slideInClass);
                            
                            const stationNameElements = incomingList.querySelectorAll('.station-name');
                            const timeElements = incomingList.querySelectorAll('.time-item span[data-original-text]');
                            
                            stationNameElements.forEach(el => scheduleMarqueeCheck(el));
                            timeElements.forEach(el => scheduleMarqueeCheck(el));

                            isAnimatingDirection = false;
                        }, 310);
                    }
                    function getStatusInfo(estimate, isOffline = false) {
                        let timeDisplay, pillBgColorClass, busId = null;

                        if (isOffline) {
                            timeDisplay = translations[currentLang].offlineStatus;
                            pillBgColorClass = 'bg-slate-200 text-slate-800';
                        } else {
                            timeDisplay = translations[currentLang].lastBusDeparted;
                            pillBgColorClass = 'bg-slate-200 text-slate-800';
                            if (estimate && estimate.etas && estimate.etas.length > 0) {
                                const closestEta = estimate.etas[0];
                                busId = closestEta.busId;
                                if (closestEta.etaTime !== null) {
                                    if (closestEta.etaTime <= 1) {
                                        timeDisplay = translations[currentLang].approaching;
                                        pillBgColorClass = 'bg-red-200 text-red-800';
                                    } else if (closestEta.etaTime <= 3) {
                                        timeDisplay = translations[currentLang].arrivingSoon;
                                        pillBgColorClass = 'bg-green-200 text-green-800';
                                    } else {
                                        timeDisplay = `${closestEta.etaTime} ${translations[currentLang].minutes}`;
                                        pillBgColorClass = 'bg-blue-200 text-blue-800';
                                    }
                                }
                            } else if (estimate && estimate.comeTime) {
                                timeDisplay = estimate.comeTime;
                            }
                        }
                        return { timeDisplay, pillBgColorClass, busId };
                    }
                    
                    function createCardHtml(stationData, direction, isFavorite) {
                        const iconHtml = isFavorite
                            ? '<span class="material-icons-outlined text-red-500">favorite</span>'
                            : `<div class="station-dot ${direction === 1 ? 'go-station' : 'back-station'}"></div>`;

                        return `
                            <div class="station-icon-container">
                                ${iconHtml}
                            </div>
                            <div class="station-content">
                                <div class="table table-fixed w-full">
                                    <div class="table-cell w-[6.5rem] align-middle">
                                        <div class="info-cycler">
                                            <div class="time-item cycler-item active">
                                                <div class="marquee-container w-full text-center">
                                                    <div class="marquee-text"><span data-original-text=""></span></div>
                                                </div>
                                            </div>
                                            <div class="plate-item cycler-item bg-yellow-200 text-yellow-800" style="display: none;">
                                                <span class="material-icons-outlined !text-sm mr-1">directions_bus</span>
                                                <span class="plate-number font-semibold whitespace-nowrap"></span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="table-cell pl-3 align-middle">
                                        <div class="marquee-container">
                                            <div class="marquee-text">
                                                <p class="station-name text-base font-medium text-slate-800" data-original-text="${stationData.node.name}">${stationData.node.name}</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    function renderOrUpdateEstimateTimes(data, direction, targetElement, isOffline = false) {
                        if (!data || !data.estimateTimes || !data.stations) {
                            targetElement.innerHTML = `<p class="text-center py-4 text-slate-500 text-sm">${translations[currentLang].noBusDataForDirection}</p>`;
                            return;
                        }

                        const filteredStations = data.stations.edges
                            .filter(edge => edge.goBack === direction)
                            .sort((a, b) => a.orderNo - b.orderNo);

                        if (filteredStations.length === 0) {
                             targetElement.innerHTML = `<p class="text-center py-4 text-slate-500 text-sm">${translations[currentLang].noBusDataForDirection}</p>`;
                            return;
                        }
                        
                        const estimatesMap = new Map(data.estimateTimes.edges.filter(e => e.node.goBack === direction).map(e => [e.node.id, e.node]));
                        
                        const nearestStopForBus = new Map();
                        if (!isOffline) {
                            data.estimateTimes.edges.forEach(e => {
                                if (e.node.goBack === direction && e.node.etas && e.node.etas.length > 0) {
                                    const eta = e.node.etas[0];
                                    if (!nearestStopForBus.has(eta.busId) || eta.etaTime < nearestStopForBus.get(eta.busId).etaTime) {
                                        nearestStopForBus.set(eta.busId, { stationId: e.node.id, etaTime: eta.etaTime, busId: eta.busId });
                                    }
                                }
                            });
                        }
                        const plateVisibleStations = new Map(Array.from(nearestStopForBus.values()).map(v => [v.stationId, v.busId]));

                        filteredStations.forEach(stationData => {
                            const station = stationData.node;
                            let card = targetElement.querySelector(`.bus-card[data-station-id="${station.id}"]`);
                            
                            if (!card) {
                                const isCurrentlyFavorite = isFavorite(currentRouteId, station.id, direction);
                                const cardHtml = createCardHtml(stationData, direction, isCurrentlyFavorite);
                                targetElement.insertAdjacentHTML('beforeend', `<div class="station-item bus-card cursor-pointer" data-station-id="${station.id}">${cardHtml}</div>`);
                                card = targetElement.lastElementChild;
                                
                                card.addEventListener('click', (e) => {
                                    if(station.lat && station.lon && map) map.flyTo([station.lat, station.lon], 17);
                                });
                                card.addEventListener('contextmenu', (e) => {
                                    e.preventDefault();
                                    const stationContextData = { routeId: parseInt(currentRouteId), routeName: currentRouteName, stationId: station.id, stationName: station.name, direction: direction, destination: direction === 1 ? currentRouteData.destination : currentRouteData.departure };
                                    showFavoriteButton(stationContextData, e.clientX, e.clientY);
                                });

                                let touchStartPos, longPressTimer;
                                card.addEventListener('touchstart', (e) => {
                                    if (e.touches.length === 1) {
                                        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                                        longPressTimer = setTimeout(() => {
                                            e.preventDefault();
                                            const stationContextData = { routeId: parseInt(currentRouteId), routeName: currentRouteName, stationId: station.id, stationName: station.name, direction: direction, destination: direction === 1 ? currentRouteData.destination : currentRouteData.departure };
                                            showFavoriteButton(stationContextData, e.touches[0].clientX, e.touches[0].clientY);
                                            longPressTimer = null;
                                        }, 700);
                                    }
                                }, { passive: true });
                                card.addEventListener('touchmove', (e) => {
                                    if (!longPressTimer || !e.touches[0] || !touchStartPos) return;
                                    const deltaX = Math.abs(e.touches[0].clientX - touchStartPos.x);
                                    const deltaY = Math.abs(e.touches[0].clientY - touchStartPos.y);
                                    if (deltaX > 10 || deltaY > 10) clearTimeout(longPressTimer);
                                });
                                card.addEventListener('touchend', () => clearTimeout(longPressTimer));
                                card.addEventListener('touchcancel', () => clearTimeout(longPressTimer));

                                scheduleMarqueeCheck(card.querySelector('.station-name'));
                            }
                            
                            const estimate = estimatesMap.get(station.id);
                            const { timeDisplay, pillBgColorClass, busId } = getStatusInfo(estimate, isOffline);

                            const timeItem = card.querySelector('.time-item');
                            const timeSpan = timeItem.querySelector('span');
                            const plateItem = card.querySelector('.plate-item');
                            const plateNumber = card.querySelector('.plate-number');
                            const iconContainer = card.querySelector('.station-icon-container');

                            const isCurrentlyFavorite = isFavorite(currentRouteId, station.id, direction);
                            const expectedIconHtml = isCurrentlyFavorite ? '<span class="material-icons-outlined text-red-500">favorite</span>' : `<div class="station-dot ${direction === 1 ? 'go-station' : 'back-station'}"></div>`;
                            if(iconContainer.innerHTML.trim() !== expectedIconHtml.trim()) {
                                iconContainer.innerHTML = expectedIconHtml;
                            }

                            if (timeSpan.dataset.originalText !== timeDisplay) {
                                timeSpan.textContent = timeDisplay;
                                timeSpan.dataset.originalText = timeDisplay;
                                scheduleMarqueeCheck(timeSpan);
                            }
                            const currentClasses = timeItem.className.split(' ');
                            const activeClass = currentClasses.includes('active') ? 'active' : '';
                            timeItem.className = `time-item cycler-item ${activeClass} ${pillBgColorClass}`;

                            if (plateVisibleStations.has(station.id)) {
							    const plateNum = plateVisibleStations.get(station.id);
							    if (plateNumber.textContent !== plateNum) {
							        plateNumber.textContent = plateNum;
							    }
							    plateItem.style.display = 'flex';
							} else {
							    plateItem.style.display = 'none';
							    if (plateItem.classList.contains('active')) {
							        plateItem.classList.remove('active');
							        timeItem.classList.add('active');
							    }
							}
                        });
                    }

                    function renderAllDirections(data, isInitialLoad, isOffline = false) {
                        if(isInitialLoad) {
                           stationListGoContent.innerHTML = '';
                           stationListBackContent.innerHTML = '';
                        }
                        renderOrUpdateEstimateTimes(data, 1, stationListGoContent, isOffline);
                        renderOrUpdateEstimateTimes(data, 2, stationListBackContent, isOffline);
                    }
                    function renderOfflineUncachedState() {
                        trackerLoading.style.display = 'none';
                        stationListGoContent.innerHTML = '';
                        stationListBackContent.innerHTML = '';
                        goDirectionButton.parentElement.style.display = 'none';
                        const offlineNotice = document.getElementById('offlineNotice');
                        offlineNotice.textContent = translations[currentLang].networkErrorOfflineView;
                        offlineNotice.classList.remove('hidden');
                    }
                    async function loadBusData(routeId, isInitialLoad = false, scrollToStationId = null) {
                        if (isInitialLoad) {
                            isFirstMapLoad = true;
                            trackerLoading.style.display = 'flex';
                            
                            // (原本的初始化 UI 邏輯保持不變，但在這裡我們稍後會根據 scrollToStationId 重新判斷方向)
                            if (currentDirection === 1) {
                                stationListGo.classList.remove('hidden');
                                stationListBack.classList.add('hidden');
                            } else {
                                stationListGo.classList.add('hidden');
                                stationListBack.classList.remove('hidden');
                            }
                    
                            stationListGo.classList.remove('slide-out-left', 'slide-in-from-right', 'slide-out-right', 'slide-in-from-left');
                            stationListBack.classList.remove('slide-out-left', 'slide-in-from-right', 'slide-out-right', 'slide-in-from-left');
                    
                            stationListGoContent.innerHTML = '';
                            stationListBackContent.innerHTML = '';
                            document.getElementById('offlineNotice').classList.add('hidden');
                            if (map) {
                                goLayerGroup.clearLayers();
                                backLayerGroup.clearLayers();
                                goBusLayerGroup.clearLayers();
                                backBusLayerGroup.clearLayers();
                                busMarkers = {};
                            }
                        }
                        updateCountdownButton.disabled = true;

                        try {
                            const result = await fetchWithRetry(GQL.QUERY_ROUTE_DETAILS, { routeId: parseInt(routeId), lang: currentLang });
                            
                            if (!result.data.route) throw new Error(translations[currentLang].routeInfoNotFound);
                            currentRouteData = result.data.route;
                            
                            // --- 新增邏輯開始：自動判斷目標站點的方向 ---
                            if (scrollToStationId && currentRouteData.stations) {
                                // 搜尋目標站點在 API 資料中的方向 (goBack: 1=去程, 2=返程)
                                const targetEdge = currentRouteData.stations.edges.find(edge => 
                                    String(edge.node.id) === String(scrollToStationId)
                                );

                                if (targetEdge) {
                                    const targetDirection = targetEdge.goBack;
                                    // 如果目標方向與當前方向不同，強制切換
                                    if (targetDirection !== currentDirection) {
                                        currentDirection = targetDirection;
                                        // 立即更新 UI 顯示正確的列表
                                        if (currentDirection === 1) {
                                            stationListGo.classList.remove('hidden');
                                            stationListBack.classList.add('hidden');
                                        } else {
                                            stationListGo.classList.add('hidden');
                                            stationListBack.classList.remove('hidden');
                                        }
                                    }
                                }
                            }
                            // --- 新增邏輯結束 ---

                            try {
                                let cachedDetails = JSON.parse(localStorage.getItem('cachedRouteDetails') || '{}');
                                cachedDetails[routeId] = currentRouteData;
                                localStorage.setItem('cachedRouteDetails', JSON.stringify(cachedDetails));
                            } catch (e) {
                                console.error("Error saving route details to localStorage", e);
                            }
                            
                            renderAllDirections(currentRouteData, isInitialLoad, false);
                            renderMap(currentRouteData);
                            
                            updateDirectionButtons(); // 這會根據上面的 currentDirection 更新按鈕狀態

                            if (scrollToStationId) {
                                await new Promise(resolve => setTimeout(resolve, 500)); // 延遲稍長一點確保 DOM 渲染完畢
                                
                                // 1. 列表滾動
                                const activeList = currentDirection === 1 ? stationListGoContent : stationListBackContent;
                                const targetStationCard = activeList.querySelector(`[data-station-id="${scrollToStationId}"]`);
                                if (targetStationCard) {
                                    targetStationCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    targetStationCard.style.transition = 'background-color 0.5s';
                                    targetStationCard.style.backgroundColor = 'rgba(59, 130, 246, 0.2)'; // 加深高亮顏色
                                    setTimeout(() => { targetStationCard.style.backgroundColor = ''; }, 1500);
                                }

                                // 2. 地圖移動
                                if (map && currentRouteData && currentRouteData.stations) {
                                    const targetStationEdge = currentRouteData.stations.edges.find(edge => 
                                        String(edge.node.id) === String(scrollToStationId) && 
                                        edge.goBack === currentDirection
                                    );

                                    if (targetStationEdge && targetStationEdge.node.lat && targetStationEdge.node.lon) {
                                        map.flyTo([targetStationEdge.node.lat, targetStationEdge.node.lon], 18, { // Zoom 改為 18 更清楚
                                            animate: true,
                                            duration: 1.5 
                                        });
                                        
                                        // 如果地圖上有對應的 Marker，自動打開 Popup
                                        // 注意：這需要遍歷 layerGroup，因為我們沒有儲存 station markers 的參照
                                        const targetLayerGroup = currentDirection === 1 ? goLayerGroup : backLayerGroup;
                                        targetLayerGroup.eachLayer(layer => {
                                            if (layer.getLatLng && layer.getLatLng().lat === targetStationEdge.node.lat && layer.getLatLng().lng === targetStationEdge.node.lon) {
                                                layer.openPopup();
                                            }
                                        });
                                    }
                                }
                            }

                        } catch (error) {
                            // (錯誤處理保持不變)
                            console.error("Failed to fetch route details:", error);
                            const isTrulyOffline = !navigator.onLine;
                            
                            let cachedDetails = JSON.parse(localStorage.getItem('cachedRouteDetails') || '{}');
                            const cachedData = cachedDetails[routeId];
                            
                            if (cachedData) {
                                if (isTrulyOffline) {
                                    showToast(translations[currentLang].networkErrorCriticalTitle, 'error');
                                    renderAllDirections(cachedData, isInitialLoad, true); 
                                } else {
                                    showToast(translations[currentLang].networkErrorWarningMessage, 'warning');
                                    renderAllDirections(cachedData, isInitialLoad, false); 
                                }
                                currentRouteData = cachedData;
                                renderMap(cachedData);
                                updateDirectionButtons();
                            } else {
                                showToast(translations[currentLang].networkErrorCriticalMessage, 'error');
                                currentRouteData = null;
                                renderOfflineUncachedState();
                            }
                        } finally {
                            trackerLoading.style.display = 'none';
                            updateCountdownButton.disabled = false;
                        }
                    }
                    function navigateToTracker(routeId, routeName, routeDesc, pushState = true, scrollToStationId = null, direction = 1) {
                        currentRouteId = routeId;
                        currentRouteName = routeName;
                        currentDirection = direction;
                        showPage('busTrackerPage', pushState);
                        routeTitle.textContent = routeName;
                        routeDescription.textContent = routeDesc;
                        loadBusData(currentRouteId, true, scrollToStationId).then(() => {
                           startInfoCycler();
                        });
                        countdownTimer.reset();
                    }
                    function createTimePillHtml(estimate) {
                        let timeDisplay = translations[currentLang].lastBusDeparted;
                        let pillBgColorClass = 'bg-slate-200';
                        if (estimate && estimate.etas && estimate.etas.length > 0) {
                             const closestEta = estimate.etas.reduce((minEta, currentEta) => {
                                const minTime = minEta.etaTime !== null ? minEta.etaTime : Infinity;
                                const currentTime = currentEta.etaTime !== null ? currentEta.etaTime : Infinity;
                                return currentTime < minTime ? currentEta : minEta;
                            }, { etaTime: Infinity });
                            if (closestEta.etaTime !== Infinity && closestEta.etaTime !== null) {
                                if (closestEta.etaTime <= 1) {
                                    timeDisplay = translations[currentLang].approaching;
                                    pillBgColorClass = 'bg-red-200';
                                } else if (closestEta.etaTime <= 3) {
                                    timeDisplay = translations[currentLang].arrivingSoon;
                                    pillBgColorClass = 'bg-green-200';
                                } else {
                                    timeDisplay = `${closestEta.etaTime}${translations[currentLang].minutes}`;
                                    pillBgColorClass = 'bg-blue-200';
                                }
                            }
                        } else if (estimate && estimate.comeTime) {
                            timeDisplay = estimate.comeTime;
                            pillBgColorClass = 'bg-slate-200';
                        } else if (!estimate) {
                            timeDisplay = translations[currentLang].noData;
                        }
                        return `<div class="time-pill px-3 py-1 ${pillBgColorClass}">
                                    <p>${timeDisplay}</p>
                                </div>`;
                    }
                    function handleGroupTabDragStart(e) {
                        draggedGroupTab = this;
                        setTimeout(() => { this.style.opacity = '0.5'; }, 0);
                    }
                    function handleGroupTabDragEnd() {
                        if(this) { this.style.opacity = '1'; }
                        draggedGroupTab = null;
                    }
                    function handleGroupTabDragOver(e) {
                        e.preventDefault();
                        const container = e.currentTarget;
                        const afterElement = getDragAfterGroupTab(container, e.clientX);
                        if (!draggedGroupTab) return;
                        if (afterElement == null) {
                            container.appendChild(draggedGroupTab);
                        } else {
                            container.insertBefore(draggedGroupTab, afterElement);
                        }
                    }
                    function getDragAfterGroupTab(container, x) {
                        const draggableElements = [...container.querySelectorAll('.group-tab[draggable="true"]')];
                        return draggableElements.reduce((closest, child) => {
                            if (child === draggedGroupTab) return closest;
                            const box = child.getBoundingClientRect();
                            const offset = x - box.left - box.width / 2;
                            if (offset < 0 && offset > closest.offset) {
                                return { offset: offset, element: child };
                            } else {
                                return closest;
                            }
                        }, { offset: Number.NEGATIVE_INFINITY }).element;
                    }
                    function renderGroupTabs() {
                        favoriteGroupTabsContainer.innerHTML = '';
                        const fragment = document.createDocumentFragment();
                        const allTab = document.createElement('div');
                        allTab.className = `group-tab ${activeGroupId === 'all' ? 'active' : ''}`;
                        allTab.textContent = translations[currentLang].all;
                        allTab.dataset.groupId = 'all';
                        allTab.addEventListener('click', () => {
                            activeGroupId = 'all';
                            displayFavoriteStations();
                        });
                        fragment.appendChild(allTab);
                        const sortableTabsContainer = document.createElement('div');
                        sortableTabsContainer.className = 'flex'; 
                        sortableTabsContainer.addEventListener('dragover', handleGroupTabDragOver);
                        favoriteData.groups.forEach(group => {
                            const groupTab = document.createElement('div');
                            groupTab.className = `group-tab ${activeGroupId === group.id ? 'active' : ''}`;
                            groupTab.textContent = group.name;
                            groupTab.dataset.groupId = group.id;
                            groupTab.draggable = true; 
                            groupTab.addEventListener('click', () => {
                                if (draggedGroupTab) return;
                                activeGroupId = group.id;
                                displayFavoriteStations();
                            });
                            groupTab.addEventListener('dragstart', handleGroupTabDragStart);
                            groupTab.addEventListener('dragend', handleGroupTabDragEnd);
                            sortableTabsContainer.appendChild(groupTab);
                        });
                        fragment.appendChild(sortableTabsContainer);
                        sortableTabsContainer.addEventListener('drop', (e) => {
                            e.preventDefault();
                            if (!draggedGroupTab) return;
                            const newOrderedIds = [...sortableTabsContainer.querySelectorAll('.group-tab[draggable="true"]')].map(tab => tab.dataset.groupId);
                            const orderedGroups = [];
                            newOrderedIds.forEach(id => {
                                const group = favoriteData.groups.find(g => g.id === id);
                                if (group) orderedGroups.push(group);
                            });
                            favoriteData.groups = orderedGroups;
                            saveFavorites();
                            displayFavoriteStations();
                        });
                        const manageTab = document.createElement('div');
                        manageTab.className = 'group-tab manage-btn';
                        manageTab.innerHTML = `<span class="material-icons-outlined text-lg align-middle">tune</span>`;
                        manageTab.addEventListener('click', () => {
                            history.pushState({ modal: 'manage-groups', page: activePage }, '', '#manage-groups');
                            renderManageGroupList();
                            manageGroupsModal.classList.add('show');
                        });
                        fragment.appendChild(manageTab);
                        favoriteGroupTabsContainer.appendChild(fragment);
                    }
                    async function displayFavoriteStations() {
                        loadFavorites();
                        renderGroupTabs();
                        favoriteListContainer.innerHTML = '';
                        let stationsToDisplay;
                        if (activeGroupId === 'all') {
                            stationsToDisplay = [...favoriteData.favorites];
                        } else {
                            stationsToDisplay = favoriteData.favorites.filter(fav => fav.groupId === activeGroupId);
                        }
                        const order = favoriteData.groupOrder[activeGroupId] || [];
                        const stationMap = new Map(stationsToDisplay.map(f => [`${f.routeId}-${f.stationId}-${f.direction}`, f]));
                        const sortedStations = order
                            .map(id => stationMap.get(id))
                            .filter(Boolean); 
                        const orderedIdsSet = new Set(order);
                        const stationsNotInOrder = stationsToDisplay.filter(f => !orderedIdsSet.has(`${f.routeId}-${f.stationId}-${f.direction}`));
                        stationsToDisplay = [...sortedStations, ...stationsNotInOrder];
                        if (favoriteData.favorites.length === 0) {
                            noFavoritesMessage.classList.remove('hidden');
                            return;
                        }
                        if (stationsToDisplay.length === 0) {
                            noFavoritesMessage.classList.remove('hidden');
                            return;
                        }
                        noFavoritesMessage.classList.add('hidden');
                        stationsToDisplay.forEach((fav) => {
                            const favCard = document.createElement('div');
                            favCard.className = 'favorite-card-item bg-white rounded-lg shadow-md';
                            favCard.dataset.routeId = fav.routeId;
                            favCard.dataset.stationId = fav.stationId;
                            favCard.dataset.direction = fav.direction;
                            const directionText = fav.destination ? `${translations[currentLang].goDirection} ${fav.destination}` : `${translations[currentLang].direction} ${fav.direction}`;
                            favCard.innerHTML = `
                                <div class="favorite-card-content">
                                    <div class="drag-handle">
                                        <span class="material-icons-outlined">drag_indicator</span>
                                    </div>
                                    <div class="flex-grow ml-2 card-tap-area">
                                        <h3 class="font-bold text-md text-slate-800">${fav.routeName}</h3>
                                        <p class="text-sm text-slate-600">${fav.stationName}</p>
                                        <p class="text-xs text-slate-400 mt-1">${directionText}</p>
                                    </div>
                                    <div class="favorite-time-display flex-shrink-0 w-28 text-right"
                                        data-route-id="${fav.routeId}"
                                        data-station-id="${fav.stationId}"
                                        data-direction="${fav.direction}">
                                        <div class="loading-spinner h-6 w-6 border-2 ml-auto"></div>
                                    </div>
                                </div>
                            `;
                            favoriteListContainer.appendChild(favCard);
                        });
                        addFavoriteCardEventListeners();
                        await refreshFavoriteTimes();
                    }
                    async function refreshFavoriteTimes() {
                        if (activePage !== 'favoriteStationsPage') return;
                        const timeDisplayDivs = document.querySelectorAll('.favorite-time-display');
                        if (timeDisplayDivs.length === 0) return;
                        const routeIdsToFetch = new Set();
                        timeDisplayDivs.forEach(div => {
                            routeIdsToFetch.add(div.dataset.routeId);
                        });
                        if (routeIdsToFetch.size === 0) return;
                        const promises = Array.from(routeIdsToFetch).map(routeId =>
                            fetchAPI(GQL.QUERY_ROUTE_DETAILS, { routeId: parseInt(routeId), lang: currentLang })
                        );
                        const results = await Promise.allSettled(promises);
                        const routeDataMap = new Map();
                        results.forEach((result, index) => {
                            if (result.status === 'fulfilled' && result.value.data.route) {
                                const routeId = Array.from(routeIdsToFetch)[index];
                                routeDataMap.set(Number(routeId), result.value.data.route);
                            }
                        });
                        timeDisplayDivs.forEach(div => {
                            const { routeId, stationId, direction } = div.dataset;
                            const routeData = routeDataMap.get(Number(routeId));
                            let timeHtml = createTimePillHtml(null);
                            if (routeData) {
                                const estimate = routeData.estimateTimes.edges.find(edge =>
                                    edge.node.id === stationId && edge.node.goBack === Number(direction)
                                )?.node;
                                timeHtml = createTimePillHtml(estimate);
                            }
                            div.innerHTML = timeHtml;
                        });
                    }
                    function handleTouchDragStart(e) {
                        const touch = e.touches[0];
                        placeholder = this; 
                        ghost = placeholder.cloneNode(true);
                        ghost.classList.add('dragging-ghost');
                        document.body.appendChild(ghost);
                        const rect = placeholder.getBoundingClientRect();
                        startTop = rect.top;
                        startYTouch = touch.clientY;
                        ghost.style.width = `${rect.width}px`;
                        ghost.style.top = `${startTop}px`;
                        ghost.style.left = `${rect.left}px`;
                        placeholder.classList.add('placeholder');
                        body.classList.add('is-dragging-item');
                        document.addEventListener('touchmove', handleTouchDragMove, { passive: false });
                        document.addEventListener('touchend', handleTouchDragEnd, { once: true });
                    }
                    function handleTouchDragMove(e) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const newTop = startTop + (touch.clientY - startYTouch);
                        ghost.style.top = `${newTop}px`;
                        const afterElement = getDragAfterElement(favoriteListContainer, touch.clientY);
                        if (afterElement) {
                            favoriteListContainer.insertBefore(placeholder, afterElement);
                        } else {
                            favoriteListContainer.appendChild(placeholder);
                        }
                    }
                    function handleTouchDragEnd() {
                        document.body.removeChild(ghost);
                        placeholder.classList.remove('placeholder');
                        body.classList.remove('is-dragging-item');
                        ghost = null;
                        placeholder = null;
                        const newOrderedElements = [...favoriteListContainer.querySelectorAll('.favorite-card-item')];
                        const newOrderedIds = newOrderedElements.map(elem => {
                            const { routeId, stationId, direction } = elem.dataset;
                            return `${routeId}-${stationId}-${direction}`;
                        });
                        favoriteData.groupOrder[activeGroupId] = newOrderedIds;
                        saveFavorites();
                        document.removeEventListener('touchmove', handleTouchDragMove);
                    }
                    function addFavoriteCardEventListeners() {
                        favoriteListContainer.querySelectorAll('.favorite-card-item').forEach(card => {
                            const { routeId, stationId, direction } = card.dataset;
                            const favData = favoriteData.favorites.find(f => f.routeId == routeId && f.stationId == stationId && f.direction == direction);
                            if (!favData) return;

                            const dragHandle = card.querySelector('.drag-handle');
                            let favLongPressTimer;

                            card.addEventListener('click', (e) => {
                                if (e.target.closest('.drag-handle')) return; 
                                if (isDraggingTouch) return;
                                navigateToTracker(favData.routeId, favData.routeName, '', true, favData.stationId, favData.direction);
                            });
                            
                            const tapArea = card.querySelector('.card-tap-area');
                            
                            tapArea.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                showFavoriteButton(favData, e.clientX, e.clientY);
                            });

                            tapArea.addEventListener('touchstart', (e) => {
                                favLongPressTimer = setTimeout(() => {
                                    e.preventDefault();
                                    showFavoriteButton(favData, e.touches[0].clientX, e.touches[0].clientY);
                                    favLongPressTimer = null;
                                }, 700);
                            }, { passive: true });
                            
                            tapArea.addEventListener('touchmove', () => clearTimeout(favLongPressTimer));
                            tapArea.addEventListener('touchend', () => clearTimeout(favLongPressTimer));
                            tapArea.addEventListener('touchcancel', () => clearTimeout(favLongPressTimer));
                            
                            dragHandle.addEventListener('touchstart', handleTouchDragStart.bind(card));
                        });
                    }
                    function getDragAfterElement(container, y) {
                        const draggableElements = [...container.querySelectorAll('.favorite-card-item:not(.placeholder)')];
                        return draggableElements.reduce((closest, child) => {
                            const box = child.getBoundingClientRect();
                            const offset = y - box.top - box.height / 2;
                            if (offset < 0 && offset > closest.offset) {
                                return { offset: offset, element: child };
                            } else {
                                return closest;
                            }
                        }, { offset: Number.NEGATIVE_INFINITY }).element;
                    }
                    const getWeatherDescription = (code) => {
                        switch (code) {
                            case 0: return translations[currentLang].weatherClear;
                            case 1: return translations[currentLang].weatherMostlyClear;
                            case 2: return translations[currentLang].weatherPartlyCloudy;
                            case 3: return translations[currentLang].weatherOvercast;
                            case 45: return translations[currentLang].weatherFog;
                            case 48: return translations[currentLang].weatherDepositingFog;
                            case 51: return translations[currentLang].weatherDrizzleLight;
                            case 53: return translations[currentLang].weatherDrizzleModerate;
                            case 55: return translations[currentLang].weatherDrizzleDense;
                            case 56: return translations[currentLang].weatherFreezingDrizzleLight;
                            case 57: return translations[currentLang].weatherFreezingDrizzleDense;
                            case 61: return translations[currentLang].weatherRainLight;
                            case 63: return translations[currentLang].weatherRainModerate;
                            case 65: return translations[currentLang].weatherRainHeavy;
                            case 66: return translations[currentLang].weatherFreezingRainLight;
                            case 67: return translations[currentLang].weatherFreezingRainHeavy;
                            case 71: return translations[currentLang].weatherSnowLight;
                            case 73: return translations[currentLang].weatherSnowModerate;
                            case 75: return translations[currentLang].weatherSnowHeavy;
                            case 77: return translations[currentLang].weatherSnowGrains;
                            case 80: return translations[currentLang].weatherRainShowersLight;
                            case 81: return translations[currentLang].weatherRainShowersModerate;
                            case 82: return translations[currentLang].weatherRainShowersHeavy;
                            case 85: return translations[currentLang].weatherSnowShowersLight;
                            case 86: return translations[currentLang].weatherSnowShowersHeavy;
                            case 95: return translations[currentLang].weatherThunderstorm;
                            case 96: return translations[currentLang].weatherThunderstormHailLight;
                            case 99: return translations[currentLang].weatherThunderstormHailHeavy;
                            default: return translations[currentLang].weatherUnknown;
                        }
                    };
                    const getWeatherIcon = (code, isDay) => {
                        switch (code) {
                            case 0: return isDay ? "☀️" : "🌙";
                            case 1: return isDay ? "🌤️" : "☁️";
                            case 2: return isDay ? "⛅" : "☁️";
                            case 3: return "☁️";
                            case 45: return "🌫️";
                            case 48: return "🌫️";
                            case 51: return "🌧️";
                            case 53: return "🌧️";
                            case 55: return "🌧️";
                            case 56: return "🌨️";
                            case 57: return "🌨️";
                            case 61: return "🌧️";
                            case 63: return "🌧️";
                            case 65: return "☔";
                            case 66: return "🧊🌧️";
                            case 67: return "🧊🌧️";
                            case 71: return "❄️";
                            case 73: return "❄️";
                            case 75: return "❄️";
                            case 77: return "🌨️";
                            case 80: return "⛈️";
                            case 81: return "⛈️";
                            case 82: return "⛈️";
                            case 85: return "🌨️";
                            case 86: return "🌨️";
                            case 95: return "⚡";
                            case 96: return "⚡";
                            case 99: return "⚡";
                            default: return "❓";
                        }
                    };
                    const fetchWeather = async () => {
                        weatherLoadingElement.classList.remove('hidden');
                        weatherErrorMessageElement.classList.add('hidden');
                        weatherInfoElement.classList.add('hidden');
                        const today = new Date();
                        const options = { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' };
                        currentDateElement.textContent = today.toLocaleDateString(currentLang === 'zh' ? 'zh-TW' : 'en-US', options);
                        const latitude = 22.6273;
                        const longitude = 120.3014;
                        const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,is_day,weather_code,wind_speed_10m&timezone=Asia%2FTaipei&forecast_days=1`;
                        try {
                            const response = await fetch(apiUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
                            }
                            const data = await response.json();
                            const current = data.current;
                            if (current) {
                                temperatureElement.textContent = current.temperature_2m;
                                apparentTemperatureElement.textContent = `${current.apparent_temperature}°C`;
                                relativeHumidityElement.textContent = `${current.relative_humidity_2m}%`;
                                windSpeedElement.textContent = `${current.wind_speed_10m} km/h`;
                                const weatherCode = current.weather_code;
                                const isDay = current.is_day;
                                const weatherDescription = getWeatherDescription(weatherCode);
                                const weatherIcon = getWeatherIcon(weatherCode, isDay);
                                weatherDescriptionElement.textContent = weatherDescription;
                                weatherIconElement.textContent = weatherIcon;
                                weatherInfoElement.classList.remove('hidden');
                                weatherDataLoaded = true; 
                            } else {
                                throw new Error(translations[currentLang].weatherLoadError);
                            }
                        } catch (error) {
                            console.error("取得天氣資料時發生錯誤:", error);
                            weatherErrorMessageElement.textContent = translations[currentLang].weatherLoadError;
                            weatherErrorMessageElement.classList.remove('hidden');
                            weatherDataLoaded = false; 
                        } finally {
                            weatherLoadingElement.classList.add('hidden');
                        }
                    };
                    async function fetchAnnouncements() {
                        loadFavorites(); 
                        if (favoriteData.favorites.length === 0) {
                            announcementLoading.classList.add('hidden');
                            noAnnouncementsMessage.classList.remove('hidden');
                            announcementContent.innerHTML = '';
                            announcementContent.appendChild(noAnnouncementsMessage);
                            announcementsDataLoaded = true;
                            return;
                        }

                        announcementLoading.classList.remove('hidden');
                        noAnnouncementsMessage.classList.add('hidden');
                        announcementContent.innerHTML = '';

                        const uniqueRouteIds = [...new Set(favoriteData.favorites.map(fav => fav.routeId))];
                        let allMessages = [];

                        try {
                            const promises = uniqueRouteIds.map(routeId =>
                                fetchAPI(GQL.QUERY_CLOGS, { routeId: parseInt(routeId) })
                            );
                            const results = await Promise.allSettled(promises);

                            results.forEach((result, index) => {
                                if (result.status === 'fulfilled' && result.value.data) {
                                    const routeId = uniqueRouteIds[index];
                                    const favRoute = favoriteData.favorites.find(fav => fav.routeId === routeId);
                                    const routeName = favRoute ? favRoute.routeName : `Route ${routeId}`;
                                    
                                    const clogMessages = result.value.data.clogMessages?.edges || [];
                                    const abnormalMessages = result.value.data.abnormalMessages?.edges || [];

                                    clogMessages.forEach(edge => {
                                        allMessages.push({
                                            type: 'clog',
                                            routeId: routeId,
                                            routeName: routeName,
                                            id: edge.node.id,
                                            title: edge.node.title,
                                            description: edge.node.description
                                        });
                                    });

                                    abnormalMessages.forEach(edge => {
                                        allMessages.push({
                                            type: 'abnormal',
                                            routeId: routeId,
                                            routeName: routeName,
                                            id: edge.node.id,
                                            title: edge.node.title,
                                            description: edge.node.description
                                        });
                                    });
                                } else if (result.status === 'rejected') {
                                    console.error(`Failed to fetch announcements for routeId: ${uniqueRouteIds[index]}`, result.reason);
                                }
                            });

                            const groupedMessages = new Map();
                            allMessages.forEach(msg => {
                                const key = `${msg.title}|||${msg.description}`;
                                if (groupedMessages.has(key)) {
                                    const existingEntry = groupedMessages.get(key);
                                    if (!existingEntry.routeNames.includes(msg.routeName)) {
                                        existingEntry.routeNames.push(msg.routeName);
                                    }
                                } else {
                                    groupedMessages.set(key, {
                                        title: msg.title,
                                        description: msg.description,
                                        routeNames: [msg.routeName]
                                    });
                                }
                            });

                            renderAnnouncements(Array.from(groupedMessages.values()));
                        } catch (error) {
                            console.error("取得訊息公告時發生錯誤:", error);
                            announcementContent.innerHTML = `<p class="text-center py-4 text-red-500">${translations[currentLang].weatherLoadError}</p>`;
                        } finally {
                            announcementLoading.classList.add('hidden');
                            announcementsDataLoaded = true;
                        }
                    }
                    function renderAnnouncements(messages) {
                        announcementContent.innerHTML = '';
                        if (messages.length === 0) {
                            noAnnouncementsMessage.classList.remove('hidden');
                            announcementContent.appendChild(noAnnouncementsMessage);
                        } else {
                            noAnnouncementsMessage.classList.add('hidden');
                            messages.forEach(msg => {
                                const messageCard = document.createElement('div');
                                messageCard.className = 'announcement-item bg-blue-100 dark:bg-slate-700 p-3 rounded-lg shadow-sm mb-3 border border-blue-200 dark:border-slate-600';
                                
                                const routeNamesHtml = msg.routeNames.map(name =>
                                    `<span class="inline-block px-2 py-0.5 rounded bg-blue-200 text-blue-800 font-medium text-xs dark:bg-blue-800 dark:text-blue-200">${name}</span>`
                                ).join(' ');

                                messageCard.innerHTML = `
                                    <h3 class="font-semibold text-slate-800 dark:text-slate-200">${routeNamesHtml} - ${msg.title}</h3>
                                    <p class="text-sm text-slate-600 dark:text-slate-400 mt-1">${msg.description}</p>
                                `;
                                announcementContent.appendChild(messageCard);
                            });
                        }
                    }

                    function renderMap(routeData) {
                        goLayerGroup.clearLayers();
                        backLayerGroup.clearLayers();

                        const goStops = [], backStops = [];
                        routeData.stations.edges.forEach(edge => {
                            if (edge.node.lat && edge.node.lon) {
                                if (edge.goBack === 1) goStops.push(edge);
                                else if (edge.goBack === 2) backStops.push(edge);
                            }
                        });
                        
                        goStops.sort((a, b) => a.orderNo - b.orderNo);
                        backStops.sort((a, b) => a.orderNo - b.orderNo);

                        drawRouteOnMap(routeData.routePoint.go, goStops, 'go');
                        drawRouteOnMap(routeData.routePoint.back, backStops, 'back');
                        updateBusMarkers(routeData.buses.edges);
                        
                        if (isFirstMapLoad) {
                            if(goStops.length > 0) map.setView([goStops[0].node.lat, goStops[0].node.lon], 16);
                            isFirstMapLoad = false;
                        }
                    }

                    function drawRouteOnMap(encodedPolyline, stops, direction) {
                        if (!encodedPolyline || stops.length === 0 || !map) return;
                        const layerGroup = direction === 'go' ? goLayerGroup : backLayerGroup;
                        
                        const decodedPath = decodePolyline(encodedPolyline);
                        L.polyline(decodedPath, { 
                            color: (direction === 'go' ? 'var(--go-color)' : 'var(--back-color)'), 
                            weight: 6, opacity: 0.7, pane: 'routePane' 
                        }).addTo(layerGroup);

                        stops.forEach(stop => {
                            const originalLatLng = L.latLng(stop.node.lat, stop.node.lon);
                            const projectedLatLng = findClosestPointOnPolyline(originalLatLng, decodedPath);
                            
                            const icon = createStationIcon(stop.orderNo, direction);
                            const marker = L.marker(projectedLatLng, { icon: icon, pane: 'stationPane' }).addTo(layerGroup);
                            
                            const estimate = currentRouteData.estimateTimes.edges.find(e => e.node.id === stop.node.id && e.node.goBack === stop.goBack);
                            marker.bindPopup(createPopupContent(stop, estimate ? estimate.node.etas : []));
                        });
                    }
                     function updateBusMarkers(buses) {
                        if(!map) return;
                        const newBusIds = new Set(buses.map(bus => bus.node.id));
                        buses.forEach(bus => {
                            const busId = bus.node.id;
                            const latLng = [bus.node.lat, bus.node.lon];
                            const direction = bus.goBack === 1 ? 'go' : 'back';
                            const layerGroup = direction === 'go' ? goBusLayerGroup : backBusLayerGroup;

                            if (busMarkers[busId]) {
                                busMarkers[busId].setLatLng(latLng);
                                if (busMarkers[busId].options.direction !== direction) {
                                   busMarkers[busId].remove();
                                   busMarkers[busId].addTo(layerGroup);
                                   busMarkers[busId].options.direction = direction;
                                }
                            } else {
                                const icon = createBusIcon(direction);
                                busMarkers[busId] = L.marker(latLng, { icon: icon, direction: direction, pane: 'busPane' })
                                    .bindPopup(`<b>${translations[currentLang].mapBusPlate} ${busId}</b>`)
                                    .addTo(layerGroup);
                            }
                        });
                        for (const busId in busMarkers) {
                            if (!newBusIds.has(busId)) {
                                busMarkers[busId].remove();
                                delete busMarkers[busId];
                            }
                        }
                    }
                    function createBusIcon(direction){return L.divIcon({className:`bus-icon ${direction==="go"?"go-bus":"back-bus"}`,html:'<span class="material-icons-outlined">directions_bus</span>',iconSize:[32,32],iconAnchor:[16,16]})}
                    function createStationIcon(number,direction){return L.divIcon({className:`station-number-icon ${direction==="go"?"go-station":"back-station"}`,html:`<span>${number}</span>`,iconSize:[24,24],iconAnchor:[12,12]})}
                    function createPopupContent(stop, etas) {
                        return `<div class="popup-header">${stop.node.name}</div><div class="popup-info"><strong>${translations[currentLang].mapStopOrder}</strong> ${stop.orderNo}</div><div class="popup-info"><strong>${translations[currentLang].mapRealTimeStatus}</strong></div>${formatEtas(etas)}`
                    }
                    function formatEtas(etas){
                        if(!etas || etas.length === 0) return `<div class="no-data">${translations[currentLang].noData}</div>`;
                        return '<div class="eta-container">' + etas.map(eta => {
                            let timeText, className = "eta-tag";
                            if(eta.etaTime <= 1){ timeText = translations[currentLang].approaching; className += " eta-approaching"; }
                            else if (eta.etaTime <= 3) { timeText = translations[currentLang].arrivingSoon; className += " eta-soon"; }
                            else { timeText = `${eta.etaTime} ${translations[currentLang].minutes}`; }
                            return `<span class="${className}"><span class="bus-id">${eta.busId}</span> ${timeText}</span>`;
                        }).join('') + '</div>';
                    }

                    let countdownTimer = {
                        remaining: updateInterval,
                        updateButton: document.getElementById('updateCountdown'),
                        updateDisplay: function() {
                            const text = `${this.remaining}${translations[currentLang].updateCountdown}`;
                            document.getElementById('updateCountdownText').textContent = text;
                        },
                        reset: function() {
                            const icon = this.updateButton.querySelector('.material-icons-outlined');
                            icon.classList.add('spin-update');
                            setTimeout(() => icon.classList.remove('spin-update'), 500);
                            this.remaining = updateInterval;
                            this.updateDisplay();
                        },
                        update: async function() {
                            this.reset();
                            if (busTrackerPage.classList.contains('active') && currentRouteId) {
                                await loadBusData(currentRouteId, false);
                            }
                        }
                    };

                    function adjustContentPadding() {
                        const mainNavHeight = mainNav.offsetHeight;
                        filterKeyboardContainer.style.display = 'block';
                        const keyboardHeight = filterKeyboardContainer.offsetHeight;
                        if (!routeSelectionPage.classList.contains('active')) {
                            filterKeyboardContainer.style.display = 'none';
                        }
                        const totalFixedBottomHeight = mainNavHeight + keyboardHeight + 10;
                        const routeSelectionContainer = document.querySelector('#routeSelectionPage .container');
                        if (routeSelectionContainer) {
                            routeSelectionContainer.style.paddingBottom = `${totalFixedBottomHeight}px`;
                        }
                    }
                    function handleHashChange(isPopState = false) {
                        const hash = window.location.hash;
                        let modalWasClosed = false;

                        if (!hash.includes('manage-groups') && manageGroupsModal.classList.contains('show')) {
                           manageGroupsModal.classList.remove('show');
                           modalWasClosed = true;
                        }
                        if (!hash.includes('/confirm/') && customConfirmModal.classList.contains('show')) {
                           customConfirmModal.classList.remove('show');
                           if (resolveCustomConfirm) resolveCustomConfirm(false);
                           modalWasClosed = true;
                        }
                        if (!hash.includes('/prompt/') && customPromptModal.classList.contains('show')) {
                           customPromptModal.classList.remove('show');
                           if (resolveCustomPrompt) resolveCustomPrompt(null);
                           modalWasClosed = true;
                        }
                        if (!hash.includes('select-group') && selectGroupModal.classList.contains('show')) {
                           selectGroupModal.classList.remove('show');
                           modalWasClosed = true;
                        }
                        return modalWasClosed;
                    }

                    function closeManageGroupsModalAndRefresh() {
                        if(window.location.hash.includes('#manage-groups')){
                            history.back();
                        } else {
                            manageGroupsModal.classList.remove('show');
                        }
                        displayFavoriteStations();
                    }
                    function showSelectGroupModal(stationData) {
                        currentStationContext = stationData;
                        history.pushState({ modal: 'select-group', page: activePage }, '', '#select-group');
                        selectGroupModalBody.innerHTML = '';
                        favoriteData.groups.forEach(group => {
                            const btn = document.createElement('button');
                            btn.className = 'w-full text-left py-3 px-4 bg-slate-100 dark:bg-slate-700 rounded-lg hover:bg-slate-200 dark:hover:bg-slate-600';
                            btn.textContent = group.name;
                            btn.addEventListener('click', () => {
                                addFavorite(stationData, group.id);
                                if (window.location.hash.includes('#select-group')) history.back();
                                selectGroupModal.classList.remove('show');
                            });
                            selectGroupModalBody.appendChild(btn);
                        });
                        const hr = document.createElement('hr');
                        hr.className = 'my-2 border-slate-200 dark:border-slate-600';
                        selectGroupModalBody.appendChild(hr);
                        const addNewGroupBtnInModal = document.createElement('button');
                        addNewGroupBtnInModal.className = 'w-full flex items-center justify-center text-left py-3 px-4 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-800 font-medium';
                        addNewGroupBtnInModal.innerHTML = `<span class="material-icons-outlined mr-2">add</span> ${translations[currentLang].addNewGroup}`;
                        
                        // BUG FIX: Replaced the entire event listener for adding a new group.
                        addNewGroupBtnInModal.addEventListener('click', async () => {
                            // 1. Close the current modal.
                            if (window.location.hash.includes('#select-group')) {
                                history.back();
                            } else {
                                selectGroupModal.classList.remove('show');
                            }
                            
                            // 2. Wait a fraction of a second for the UI to settle before showing the next modal.
                            await new Promise(resolve => setTimeout(resolve, 50)); 

                            // 3. Show the prompt to get the new group name.
                            const name = await customPrompt(
                                translations[currentLang].addNewGroup,
                                translations[currentLang].enterNewGroupName
                            );

                            if (name && name.trim()) {
                                const newGroupName = name.trim();
                                
                                // 4. Check for duplicate name.
                                if (favoriteData.groups.some(g => g.name.toLowerCase() === newGroupName.toLowerCase())) {
                                    showToast(translations[currentLang].groupNameExists, 'warning');
                                    return; 
                                }

                                // 5. Create the new group and save it.
                                const newGroup = {
                                    id: Date.now().toString(),
                                    name: newGroupName,
                                    isDefault: false
                                };
                                favoriteData.groups.push(newGroup);
                                saveFavorites();
                                
                                // 6. Add the current station (from the outer scope) to this new group.
                                addFavorite(stationData, newGroup.id);
                                
                                // 7. Give user feedback.
                                showToast(`${translations[currentLang].addedToGroup} "${newGroupName}"`, 'info');
                            }
                        });

                        selectGroupModalBody.appendChild(addNewGroupBtnInModal);
                        selectGroupModal.classList.add('show');
                    }
                    const getDragAfterGroupItem = (container, y) => {
                        const draggableElements = [...container.querySelectorAll('.manage-group-item:not(.group-placeholder)')];
                        return draggableElements.reduce((closest, child) => {
                            if (child === groupPlaceholder) return closest;
                            const box = child.getBoundingClientRect();
                            const offset = y - box.top - box.height / 2;
                            if (offset < 0 && offset > closest.offset) {
                                return { offset: offset, element: child };
                            } else {
                                return closest;
                            }
                        }, { offset: Number.NEGATIVE_INFINITY }).element;
                    };
                    function handleGroupTouchDragStart(e) {
                        const touch = e.touches[0];
                        groupPlaceholder = this;
                        groupGhost = groupPlaceholder.cloneNode(true);
                        groupGhost.classList.add('dragging-ghost');
                        document.body.appendChild(groupGhost);
                        const rect = groupPlaceholder.getBoundingClientRect();
                        startTopGroup = rect.top;
                        startYGroupTouch = touch.clientY;
                        groupGhost.style.width = `${rect.width}px`;
                        groupGhost.style.top = `${startTopGroup}px`;
                        groupGhost.style.left = `${rect.left}px`;
                        groupPlaceholder.classList.add('group-placeholder');
                        body.classList.add('is-dragging-item');
                        document.addEventListener('touchmove', handleGroupTouchDragMove, { passive: false });
                        document.addEventListener('touchend', handleGroupTouchDragEnd, { once: true });
                    }
                    function handleGroupTouchDragMove(e) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const newTop = startTopGroup + (touch.clientY - startYGroupTouch);
                        if(groupGhost) groupGhost.style.top = `${newTop}px`;
                        const afterElement = getDragAfterGroupItem(manageGroupsModalBody, touch.clientY);
                        if (afterElement) {
                            manageGroupsModalBody.insertBefore(groupPlaceholder, afterElement);
                        } else {
                            manageGroupsModalBody.appendChild(groupPlaceholder);
                        }
                    }
                    function handleGroupTouchDragEnd() {
                        if (groupGhost) document.body.removeChild(groupGhost);
                        if (groupPlaceholder) groupPlaceholder.classList.remove('group-placeholder');
                        body.classList.remove('is-dragging-item');
                        groupGhost = null;
                        groupPlaceholder = null;
                        const newOrderedElements = [...manageGroupsModalBody.querySelectorAll('.manage-group-item')];
                        const newOrderedIds = newOrderedElements.map(elem => elem.dataset.groupId);
                        favoriteData.groups.sort((a, b) => newOrderedIds.indexOf(a.id) - newOrderedIds.indexOf(b.id));
                        saveFavorites();
                        document.removeEventListener('touchmove', handleGroupTouchDragMove);
                    }
                    function handleManageGroupsDragOver(e) {
                        e.preventDefault();
                        if (!draggedGroupItem) return;
                        const afterElement = getDragAfterGroupItem(manageGroupsModalBody, e.clientY);
                        if (afterElement) {
                            manageGroupsModalBody.insertBefore(draggedGroupItem, afterElement);
                        } else {
                            manageGroupsModalBody.appendChild(draggedGroupItem);
                        }
                    }
                    function handleManageGroupsDrop(e) {
                        e.preventDefault();
                        if (!draggedGroupItem) return;
                        const newOrderedElements = [...manageGroupsModalBody.querySelectorAll('.manage-group-item')];
                        const newOrderedIds = newOrderedElements.map(elem => elem.dataset.groupId);
                        favoriteData.groups.sort((a, b) => newOrderedIds.indexOf(a.id) - newOrderedIds.indexOf(b.id));
                        saveFavorites();
                    }
                    function renderManageGroupList() {
                        manageGroupsModalBody.innerHTML = '';
                        manageGroupsModalBody.removeEventListener('dragover', handleManageGroupsDragOver);
                        manageGroupsModalBody.removeEventListener('drop', handleManageGroupsDrop);

                         favoriteData.groups.filter(g => g.id !== 'all').forEach(group => {
                             const groupItem = document.createElement('div');
                             groupItem.className = 'manage-group-item flex items-center justify-between p-2 bg-slate-100 dark:bg-slate-700 rounded-lg';
                             groupItem.draggable = true;
                             groupItem.dataset.groupId = group.id;
                             
                             const dragArea = document.createElement('div');
                             dragArea.className = 'flex items-center group-drag-handle cursor-grab flex-grow';
                             dragArea.innerHTML = `
                                 <span class="material-icons-outlined mr-2 text-slate-500 touch-none">drag_indicator</span>
                                 <span class="font-medium">${group.name}</span>
                             `;
                             groupItem.appendChild(dragArea);
                             
                             const controls = document.createElement('div');
                             controls.className = 'flex items-center space-x-2';
                             const renameBtn = document.createElement('button');
                             renameBtn.className = 'p-1 rounded-full hover:bg-slate-300 dark:hover:bg-slate-600';
                             renameBtn.innerHTML = `<span class="material-icons-outlined text-lg">edit</span>`;
                             renameBtn.addEventListener('click', () => renameGroup(group.id, group.name));
                             controls.appendChild(renameBtn);
                             const deleteBtn = document.createElement('button');
                             deleteBtn.className = 'p-1 rounded-full hover:bg-slate-300 dark:hover:bg-slate-600';
                             deleteBtn.innerHTML = `<span class="material-icons-outlined text-lg text-red-500">delete_outline</span>`;
                             deleteBtn.addEventListener('click', () => deleteGroup(group.id));
                             controls.appendChild(deleteBtn);
                             groupItem.appendChild(controls);

                            groupItem.addEventListener('dragstart', (e) => {
                                draggedGroupItem = e.target.closest('.manage-group-item');
                                setTimeout(() => { if(draggedGroupItem) draggedGroupItem.style.opacity = '0.5'; }, 0);
                            });
                             
                            groupItem.addEventListener('dragend', (e) => {
                                if (draggedGroupItem) draggedGroupItem.style.opacity = '1';
                                draggedGroupItem = null;
                            });

                            dragArea.addEventListener('touchstart', handleGroupTouchDragStart.bind(groupItem));
                             
                            manageGroupsModalBody.appendChild(groupItem);
                         });
                         
                        manageGroupsModalBody.addEventListener('dragover', handleManageGroupsDragOver);
                        manageGroupsModalBody.addEventListener('drop', handleManageGroupsDrop);
                    }
                    async function addNewGroup() {
                        const name = await customPrompt(
                            translations[currentLang].addNewGroup,
                            translations[currentLang].enterNewGroupName
                        );
                        if (name && name.trim()) {
                            addNewGroupAction(name.trim());
                        }
                    }
                    function addNewGroupAction(name) {
                        if (favoriteData.groups.some(g => g.id !== 'all' && g.name.toLowerCase() === name.toLowerCase())) {
                            showToast(translations[currentLang].groupNameExists, 'warning');
                            return;
                        }
                        const newGroup = {
                            id: Date.now().toString(),
                            name: name,
                            isDefault: false
                        };
                        favoriteData.groups.push(newGroup);
                        saveFavorites();
                        renderManageGroupList();
                    }
                    async function renameGroup(groupId, currentName) {
                        const newName = await customPrompt(
                            translations[currentLang].enterRename,
                            '',
                            currentName
                        );
                        if (newName && newName.trim() && newName.trim() !== currentName) {
                            if (favoriteData.groups.some(g => g.id !== 'all' && g.name.toLowerCase() === newName.trim().toLowerCase() && g.id !== groupId)) {
                                return;
                            }
                            const group = favoriteData.groups.find(g => g.id === groupId);
                            if (group) {
                                group.name = newName.trim();
                                saveFavorites();
                                renderManageGroupList();
                            }
                        }
                    }
                    async function deleteGroup(groupId) {
                        if (groupId === 'all') {
                            return;
                        }
                        const confirmed = await customConfirm(
                            translations[currentLang].deleteGroupConfirm,
                            ''
                        );
                        if (confirmed) {
                            favoriteData.groups = favoriteData.groups.filter(g => g.id !== groupId);
                            favoriteData.favorites = favoriteData.favorites.filter(f => f.groupId !== groupId);
                            if (activeGroupId === groupId) {
                                activeGroupId = 'all'; 
                            }
                            saveFavorites();
                            renderManageGroupList();
                        }
                    }
                    const mapPageNameToId = (name) => {
                        switch (name) {
                            case 'home': return 'homePage';
                            case 'dynamic': return 'routeSelectionPage';
                            case 'tracker': return 'busTrackerPage';
                            case 'favoriteStations': return 'favoriteStationsPage';
                            case 'mrt': return 'mrtPage';
                            case 'settings': return 'settingsPage';
                            default: return null;
                        }
                    };
                    async function initializeAppUI() {
                        applyInitialTheme();
                        
                        if (!map) {
                            map = L.map('map').setView([22.6273, 120.3014], 16);
                            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
                            
                            map.createPane('routePane').style.zIndex = 350;
                            map.createPane('stationPane').style.zIndex = 450;
                            map.createPane('busPane').style.zIndex = 550;

                            goLayerGroup = L.layerGroup().addTo(map);
                            backLayerGroup = L.layerGroup();
                            goBusLayerGroup = L.layerGroup().addTo(map);
                            backBusLayerGroup = L.layerGroup();
                        }

                        const splashScreenEnabled = localStorage.getItem('splashScreenEnabled') !== 'false';
                        splashScreenToggle.checked = splashScreenEnabled;
                        const mapEnabled = localStorage.getItem('mapDisplayEnabled') !== 'false';
                        mapDisplayToggle.checked = mapEnabled;
                        updateTrackerLayout();

                        currentLang = localStorage.getItem("lang") || "zh";
                        languageSelect.value = currentLang;
                        updateInterval = parseInt(localStorage.getItem('updateInterval'), 10) || 20;
                        updateIntervalSelect.value = updateInterval;
                        countdownTimer.remaining = updateInterval;
                        loadFavorites(); 
                        applyTranslations(); 
                        defaultStartPage = localStorage.getItem('defaultStartPage') || 'home';
                        defaultStartPageSelect.value = defaultStartPage;
                        
                        darkModeToggle.addEventListener('change', () => {
                            if (darkModeToggle.checked) {
                                body.classList.add('dark-mode');
                                localStorage.setItem('darkMode', 'true');
                            } else {
                                body.classList.remove('dark-mode');
                                localStorage.setItem('darkMode', 'false');
                            }
                            updateMrtIframeSrc();
                        });
                        splashScreenToggle.addEventListener('change', () => {
                            localStorage.setItem('splashScreenEnabled', splashScreenToggle.checked);
                        });
                        mapDisplayToggle.addEventListener('change', () => {
                            localStorage.setItem('mapDisplayEnabled', mapDisplayToggle.checked);
                            updateTrackerLayout();
                        });
                        languageSelect.addEventListener('change', async (e) => {
                            await setLanguage(e.target.value);
                        });
                        favoriteActionButton.addEventListener('click', () => {
                            if (currentStationContext) {
                                const isCurrentlyFavorite = isFavorite(currentStationContext.routeId, currentStationContext.stationId, currentStationContext.direction);
                                if (isCurrentlyFavorite) {
                                    removeFavorite(currentStationContext);
                                } else {
                                    showSelectGroupModal(currentStationContext);
                                }
                                hideFavoriteButton();
                            }
                        });
                        
                        window.addEventListener('popstate', async (event) => {
                            const modalWasClosed = handleHashChange(true);
                            if (modalWasClosed) {
                                event.stopImmediatePropagation();
                                return;
                            }
                            const destinationState = event.state || { page: 'homePage' };
                            const destinationPageId = destinationState.page;
                            if (destinationPageId && destinationPageId !== activePage) {
                                await showPage(destinationPageId, false);
                            }
                        });

                        filterKeyboard.addEventListener('click', (e) => {
                            const button = e.target.closest('button');
                            if (!button) return;
                            const value = button.dataset.filter;
                            const type = button.dataset.type;
                            button.classList.add('active-keyboard-button');
                            setTimeout(() => {
                                button.classList.remove('active-keyboard-button');
                            }, 150);
                            if (type === 'category') {
                                let searchPrefix;
                                const categoryObj = categoryFilters.find(cat => cat.filterValue === value);
                                if(categoryObj && translations[currentLang][categoryObj.i18nKey]){
                                     searchPrefix = translations[currentLang][categoryObj.i18nKey];
                                } else {
                                     searchPrefix = button.textContent;
                                }
                                selectedCategoryPrefix = searchPrefix;
                                categoryDisplay.textContent = translations[currentLang][categoryDisplayMap[value]] || translations[currentLang].allRoutes;
                                routeSearchInput.value = '';
                            } else if (type === 'number') {
                                routeSearchInput.value += value;
                            } else if (type === 'action') {
                                if (value === 'reset') {
                                    resetSearch();
                                } else if (value === 'backspace') {
                                    routeSearchInput.value = routeSearchInput.value.slice(0, -1);
                                }
                            }
                            const fullSearchTerm = selectedCategoryPrefix + routeSearchInput.value;
                            applySearch(fullSearchTerm);
                        });
                        closeSelectGroupModal.addEventListener('click', () => {
                            if (window.location.hash.includes('#select-group')) history.back();
                            selectGroupModal.classList.remove('show');
                        });
                        closeManageGroupsModal.addEventListener('click', closeManageGroupsModalAndRefresh);
                        addNewGroupBtn.addEventListener('click', addNewGroup);
                        goDirectionButton.addEventListener('click', () => handleDirectionToggle(1));
                        backDirectionButton.addEventListener('click', () => handleDirectionToggle(2));
                        const estimateTimesSection = document.getElementById('estimateTimesSection');
                        let touchStartX, touchStartY, touchEndX, touchEndY;
                        estimateTimesSection.addEventListener('touchstart', (e) => {
                            if (e.target.closest('#dragHandle')) return;
                            if (e.touches.length !== 1) return;
                            touchStartX = e.touches[0].clientX;
                            touchStartY = e.touches[0].clientY;
                            touchEndX = 0;
                            touchEndY = 0;
                        }, { passive: true });
                        estimateTimesSection.addEventListener('touchmove', (e) => {
                            if (e.touches.length !== 1) return;
                            touchEndX = e.touches[0].clientX;
                            touchEndY = e.touches[0].clientY;
                        }, { passive: true });
                        estimateTimesSection.addEventListener('touchend', (e) => {
                            if (e.target.closest('#dragHandle')) return;
                            if (touchEndX === 0) return;
                            const diffX = touchStartX - touchEndX;
                            const diffY = touchStartY - touchEndY;
                            if (Math.abs(diffX) > 50 && Math.abs(diffX) > Math.abs(diffY)) {
                                handleDirectionToggle(diffX > 0 ? 2 : 1);
                            }
                            touchStartX = 0;
                            touchStartY = 0;
                            touchEndX = 0;
                            touchEndY = 0;
                        });
                        updateCountdownButton.addEventListener('click', () => {
                            countdownTimer.update();
                        });
                        mainNav.addEventListener('click', (e) => {
                            const button = e.target.closest('button');
                            if (!button) return;
                            const page = button.dataset.page;
                            if (page === 'dynamic') {
                                showPage('routeSelectionPage');
                            }
                            else if (page === 'favoriteStations') {
                                showPage('favoriteStationsPage');
                            }
                            else if (page === 'mrt') {
                                showPage('mrtPage');
                            }
                            else if (page === 'home') {
                                showPage('homePage');
                            }
                            else if (page === 'settings') {
                                showPage('settingsPage');
                            }
                        });
                        defaultStartPageSelect.addEventListener('change', () => {
                            const newDefault = defaultStartPageSelect.value;
                            localStorage.setItem('defaultStartPage', newDefault);
                            defaultStartPage = newDefault;
                        });
                        updateIntervalSelect.addEventListener('change', () => {
                            const newInterval = parseInt(updateIntervalSelect.value, 10);
                            updateInterval = newInterval;
                            localStorage.setItem('updateInterval', newInterval);
                            if (busTrackerPage.classList.contains('active')) {
                                countdownTimer.reset();
                            }
                        });
                        document.addEventListener('click', (e) => {
                            if (!favoriteActionButton.contains(e.target) && favoriteActionButton.classList.contains('show')) {
                                hideFavoriteButton();
                            }
                        });
                        let favTouchStartX = 0, favTouchStartY = 0;
                        let favTouchEndX = 0, favTouchEndY = 0;
                        favoritePage.addEventListener('touchstart', e => {
                            if (e.target.closest('.drag-handle') || e.target.closest('.group-tab')) return;
                            favTouchStartX = e.changedTouches[0].screenX;
                            favTouchStartY = e.changedTouches[0].screenY; 
                        }, { passive: true });
                        favoritePage.addEventListener('touchend', e => {
                            if (e.target.closest('.drag-handle') || e.target.closest('.group-tab')) return;
                            favTouchEndX = e.changedTouches[0].screenX;
                            favTouchEndY = e.changedTouches[0].screenY; 
                            handleFavoriteSwipe();
                        }, { passive: true });
                        function handleFavoriteSwipe() {
                            const swipeThreshold = 50; 
                            if (favTouchEndX === 0 || favTouchEndY === 0) return; 
                            const diffX = favTouchEndX - favTouchStartX;
                            const diffY = favTouchEndY - favTouchStartY;
                            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > swipeThreshold) {
                                const groupTabsIds = ['all', ...favoriteData.groups.map(g => g.id)];
                                const currentGroupIndex = groupTabsIds.indexOf(activeGroupId);
                                if (currentGroupIndex === -1) return;
                                let nextGroupIndex;
                                if (diffX < 0) {
                                    nextGroupIndex = (currentGroupIndex + 1) % groupTabsIds.length;
                                } else { 
                                    nextGroupIndex = (currentGroupIndex - 1 + groupTabsIds.length) % groupTabsIds.length;
                                }
                                activeGroupId = groupTabsIds[nextGroupIndex];
                                displayFavoriteStations();
                            }
                            favTouchStartX = 0;
                            favTouchStartY = 0;
                            favTouchEndX = 0;
                            favTouchEndY = 0;
                        }

                        const dragHandle = document.getElementById('dragHandle');
                        const panel = document.getElementById('estimateTimesSection');
                        let isDragging = false;
                        let startY, startHeight;
                        const onDragStart = (e) => {
                            isDragging = true;
                            startY = e.touches ? e.touches[0].clientY : e.clientY;
                            startHeight = panel.offsetHeight;
                            panel.style.transition = 'none';
                            document.body.style.cursor = 'ns-resize';
                            e.preventDefault();
                        };
                        const onDragMove = (e) => {
                            if (!isDragging) return;
                            const contentWrapper = document.getElementById('content-wrapper');
                            const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                            const deltaY = startY - currentY;

                            const finalMinHeight = 60; 

                            const maxHeight = contentWrapper.offsetHeight;
                            
                            const newHeight = Math.min(Math.max(startHeight + deltaY, finalMinHeight), maxHeight);
                            
                            panel.style.height = `${newHeight}px`;
                            if(map) map.invalidateSize();
                        };

                        const onDragEnd = () => {
                            isDragging = false;
                            panel.style.transition = '';
                            document.body.style.cursor = '';
                            if(map) map.invalidateSize();
                        };
                        dragHandle.addEventListener('mousedown', onDragStart);
                        document.addEventListener('mousemove', onDragMove);
                        document.addEventListener('mouseup', onDragEnd);
                        dragHandle.addEventListener('touchstart', onDragStart, { passive: false });
                        document.addEventListener('touchmove', onDragMove, { passive: true });
                        document.addEventListener('touchend', onDragEnd);


                        adjustContentPadding();
                        window.addEventListener('resize', () => {
                            adjustContentPadding();
                            if (busTrackerPage.classList.contains('active')) {
                                updateDirectionButtons();
                            }
                        });
                        window.addEventListener('hashchange', () => handleHashChange(false));
                        const urlParams = new URLSearchParams(window.location.search);
                        const pageFromUrl = urlParams.get('page');
                        const routeIdFromUrl = urlParams.get('route'); 

                        let initialPageId = mapPageNameToId(pageFromUrl) || mapPageNameToId(defaultStartPage) || 'homePage';

                        if (initialPageId === 'busTrackerPage' && routeIdFromUrl) {
                            currentRouteId = routeIdFromUrl; 
                        }
                        
                        await showPage(initialPageId, false);
                        history.replaceState({ page: initialPageId, routeId: routeIdFromUrl }, '', window.location.href);

                        handleHashChange(false);
                        updateNavHighlight(); 
                        countdownInterval = setInterval(() => {
                            if (busTrackerPage.classList.contains('active') && navigator.onLine) {
                                updateCountdownButton.style.display = "flex";
                                countdownTimer.remaining--;
                                if (countdownTimer.remaining <= 0) {
                                    countdownTimer.update();
                                }
                                countdownTimer.updateDisplay();
                            } else {
                                updateCountdownButton.style.display = "none";
                            }
                        }, 1000);
                        window.addEventListener('online', () => {
                            if (busTrackerPage.classList.contains('active')) {
                                updateCountdownButton.style.display = "flex";
                                countdownTimer.update();
                            }
                        });
                        window.addEventListener('offline', () => {
                            updateCountdownButton.style.display = "none";
                        });

                        document.addEventListener('visibilitychange', () => {
                            if (document.visibilityState === 'visible') {
                                updateNavHighlight();
                                if (busTrackerPage.classList.contains('active')) {
                                    // Delay update slightly to allow network to reconnect
                                    setTimeout(() => {
                                        if (navigator.onLine) {
                                            countdownTimer.update();
                                        }
                                    }, 1000);
                                }
                            }
                        });

                    }
                    async function loadInitialData() {
                        await initRouteSelection();
                        const urlParams = new URLSearchParams(window.location.search);
                        const pageFromUrl = urlParams.get('page');
                        const routeIdFromUrl = urlParams.get('route');
                        // 新增：讀取 station 參數
                        const stationIdFromUrl = urlParams.get('station'); 

                        let initialPageId = mapPageNameToId(pageFromUrl) || mapPageNameToId(defaultStartPage) || 'homePage';

                        if (initialPageId === 'busTrackerPage' && routeIdFromUrl) {
                            const route = allRoutes.find(r => r.id.toString() === routeIdFromUrl);
                            if (route) {
                                // 修改：將 stationIdFromUrl 傳入第 5 個參數 (scrollToStationId)
                                // navigateToTracker(routeId, routeName, routeDesc, pushState, scrollToStationId, direction)
                                navigateToTracker(route.id, route.name, route.description, false, stationIdFromUrl, 1);
                            } else {
                                await showPage('routeSelectionPage', true);
                            }
                        }
                    }
                    await initializeAppUI(); 
                    await loadInitialData(); 
                } catch (error) {
                    console.error("A critical error occurred during initialization and was caught by the safety net:", error);
                    const splash = document.getElementById('splashScreen');
                    if (splash) splash.remove();
                    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                    document.getElementById('homePage').classList.add('active');
                    const lang = localStorage.getItem("lang") || "zh";
                    const criticalErrorTranslations = {
                        zh: { title: '網路連線失敗', message: '無法獲取公車資料，功能將受限。請檢查網路後重試。'},
                        en: { title: 'Network Connection Failed', message: 'Could not fetch bus data, functionality is limited. Please check your connection and retry.' }
                    };
                    const announcementContent = document.getElementById('announcementContent');
                    const errorCard = document.createElement('div');
                    errorCard.className = 'error-announcement announcement-item bg-red-100 dark:bg-red-900 p-3 rounded-lg shadow-sm mb-3 border border-red-300 dark:border-red-700';
                    errorCard.innerHTML = `
                        <h3 class="font-semibold text-red-800 dark:text-red-200 flex items-center">
                            <span class="material-icons-outlined mr-2">wifi_off</span>
                            ${criticalErrorTranslations[lang].title}
                        </h3>
                        <p class="text-sm text-red-700 dark:text-red-300 mt-1">${criticalErrorTranslations[lang].message}</p>
                    `;
                    if(announcementContent) {
                        announcementContent.innerHTML = ''; 
                        announcementContent.appendChild(errorCard);
                    }
                }
            } 
        });
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>